Classes and Inheritance

class B {
class A{}
 class Animal {
    String a;
    public static void main(String[] args) {

        class Test2 {} //Compiler generates ---> Animal$1Test2.class
        class Test {}  //Compiler generates ---> Animal$1Test.class
       
    }
    
    void test() {
    	 class Test3 {
    		 class Test {}
    	 }
    }
    
    class Test3 {}
    class Test {} //Compiler generates ---> Animal$Test.class

	class B{} //DOES NOT COMPILE
}
}

In another class which is in the same package:

public static void main(String[] args) {
		
		B b; //DOES COMPILE
		A a;  //DOES COMPILE
		Test3 t;  //DOES NOT COMPILE
	}

// Bear.java ***
class Bird {}
class Bear {}
class Fish {} 
//DOES COMPILE

// ClownFish.java
protected class ClownFish{} // DOES NOT COMPILE
// BlueTang.java
private class BlueTang {} // DOES NOT COMPILE


this
The 'this' reference refers to the current instance of the
class and can be used to access any member of the class, including inherited members. It can
be used in any instance method, constructor, or instance initializer block. It cannot be used
when there is no implicit instance of the class, such as in a static method or static initializer
block.

this vs super Example

class Insect {
protected int numberOfLegs = 4;
String label = "buggy";
}

public class Beetle extends Insect {
protected int numberOfLegs = 6;
short age = 3;
public void printData() {
 System.out.println(this.label); //Looks in current and within inheritance tree (superclasses); DOES COMPILE
 System.out.println(super.label); //Only looks in superclasses; DOES COMPILE
 System.out.println(this.age); //Finds it in current class;  DOES NOT COMPILE
 System.out.println(super.age); //Only looks in superclasses; DOES NOT COMPILE
 System.out.println(numberOfLegs); //DOES COMPILE  //Looks in current and within inheritance tree (superclasses); Java checks outward, starting with the narrowest scope. 
												  //For this reason, the value of numberOfLegs in the Beetle class is used, and 6 is printed. 
												 //In this example, this.numberOfLegs and super.numberOfLegs refer to different variables with distinct values.; 
 }
 public static void main(String []n) {
 new Beetle().printData();
 }
 }
 
 *** Remember, while 'this' includes current and inherited members, 'super' only includes inherited members.
 
 
 
 constructors
 
public class DemoMain {
	
	public DemoMain(int i) {};
	
	public static void main(String[] args) {
		DemoMain dm = new DemoMain(); //DOES NOT COMPILE - compiler only inserts the default constructor when no constructors are defined.
	}
	***Having only private constructors in a class tells the compiler not to
	   provide a default no-argument constructor. It also prevents other classes
	   from instantiating the class. This is useful when a class has only static
	   methods or the developer wants to have full control of all calls to create
	   new instances of the class.
}

 
this()


public class Hamster {
 private String color;
 private int weight;
  public Hamster() {}
 public Hamster(int weight, String color) { // First constructor
 this.weight = weight;
 this.color = color;
 }
 public Hamster(int weight) { // Second constructor
 this.weight = weight;
 color = "brown";
 }
  void test() {
		 this() //DOES NOT COMPILE
  }
}


***public Hamster(int weight) { // Second constructor
 this(weight, "brown");
 }
 
 When this() is used with parentheses, Java calls another
constructor on the same instance of the class.
Despite using the same keyword, this and this() are very different. The first, 'this',
refers to an instance of the class, while the second, 'this()', refers to a constructor call
within the class. The exam may try to trick you by using both together, so make sure you
know which one to use and why. Calling this() has one special rule you need to know. If you choose to call it, the this() call
must be the first statement in the constructor. The side effect of this is that there can be only
one call to this() in any constructor.

public Hamster(int weight) { //Second constructor
 
    this(weight, "color");
	System.out.println("obj");	
    this(weight, "aaa"); //DOES NOT COMPILE
	
}

public Hamster(int weight) { //Second constructor
 
	System.out.println("obj");	
    this(weight, "color"); //DOES NOT COMPILE
	
}
or
public Hamster(int weight) { //Second constructor
 
    this(weight, "color"); //DOES COMPILE
	System.out.println("obj");
}
or
public Hamster(int weight) { //Second constructor
 
    this(); //DOES COMPILE
	System.out.println("obj");
	 this.weight = weight;
}

public Hamster(int weight) { // Second constructor
	 
	this(weight);	 //DOES NOT COMPILE
}

**Cannot have multiple this() only single this() and it must be first line within constructor; and it cannot call 'itself' using this()

The compiler and cyclic this():

public class Gopher {
 public Gopher(int dugHoles) {
 this(5); // DOES NOT COMPILE
 }
}

public class Gopher {
 public Gopher() {
 this(5); // DOES NOT COMPILE
 }
 public Gopher(int dugHoles) {
 this(); // DOES NOT COMPILE; if we comment out this line, then code compiles OR other line 'this(5);' then code again compiles. Notice we have two compile errors
 }
} 

Rukes for constructors:

■ A class can contain many overloaded constructors, provided the signature for each is distinct.
■ The compiler inserts a default no-argument constructor if no constructors are declared.
■ If a constructor calls this(), then it must be the first line of the constructor.
■ Java does not allow cyclic constructor calls.


--------------------------------------

super()

class Mammal{
	//public Mammal() {System.out.println("ff");} DEAFULT CONSTRUCTOR IS NOT CREATED ***
	public Mammal(int i) {System.out.println("aa");}
	public Mammal(int i, String ff) {System.out.println("ff");}
	public int weight;
}

public class Hamster extends Mammal{
	
	 private String color;
	 private int weight;
	 
	 public Hamster() { this(2, "ffg");}
	 
	 public Hamster(int weight, String color) { // First constructor
		 this(1);

	 }
	 public Hamster(int weight) { // Second constructor
		 super(2, ""); //In case we are not using this() such as current 'public Hamster(int weight) {...}' constructor, java automatically inserts super() if we don't specify and super method call, as we did with 'super(2, "");'	 	
	 }
	 
	 public Hamster(long kk) {
		 super(1,"fFG");
	 }
	 
	 void test() {
		 super(1); //DOES NOT COMPILE
	 }
	 
	 public static void main(String[] args) {
		new Hamster(2,  "");
	}
	 
}
*** The first statement of every constructor is a call to a parent constructor using super() or another constructor in the class using this(). They cannot be together. super() must be on the first line if this() is not used, and vice-reversed.

*** In every subclass constructor implicit super() call is made by the compiler. Obviously, it tries to call no-arg super constructor if it exists. Superclass no-args constructor will not be created
if there is already definde any other superclass constructor. And if that constructor doesn't exist, calls from constructors in a subclass to a superclass no-arg constructor won't be made and we get DOES NOT COMPILE error. 
In that case you have to find appropriate overloaded superclass constructor and call it with super(params1, paramsN) or manually define a default constructor in a superclass.


■ The first line of every constructor is a call to a parent constructor using super() or an overloaded constructor using this().
■ If the constructor does not contain a this() or super() reference, then the compiler automatically inserts super() with no arguments as the first line of the constructor.
■ If a constructor calls super(), then it must be the first line of the constructor


--------------------------------------

Initializing Classes with inheritance and static

***First, we initialize the class, which involves invoking all static members in the class hierarchy, starting with the
highest superclass and working downward. This is sometimes referred to as loading the class. 

The most important rules with class initialization is that it happens at most once for each class.

The Java Virtual Machine (JVM) controls when the class is initialized, although you can
assume the class is loaded before it is used. The class may be initialized when the program
first starts, when a static member of the class is referenced, or shortly before an instance of
the class is created

Initialize Class X
1. If there is a superclass Y of X, then initialize class Y first.
2. Process all static variable declarations in the order in which they appear in the class.
3. Process all static initializers in the order in which they appear in the class.


**Fields and instance initializer blocks are run in the order in which
they appear in the file.

**The constructor runs after all fields and instance initializer blocks
have run.

Evauluate order of initialization for static members in inheritance hierarchy:

Follow all three cases!!!

Example 1:

public class Test{
	 static {System.out.println("in Test static block upper"); }
	 private Helper h1 = new Helper("pera");
	 private static Helper h = new Helper();
	 private static final int x = test32();
	 private String color;
	 
	 {System.out.println("Upper block Test");}
	 
	 static int test32() {
		 System.out.println("in test32...");
		 return 2;
	 }
	 
	 public Test(int i) {
		 this("ggg");
		 System.out.println("yy");
	 }
	 
	 public Test(String i) {
		 System.out.println("ff");
	 }
	 
	 public static void main(String[] args) {
		 System.out.println("From test main");
		 //new Test(1);
		 /**
		  * Output:
		  * 
		  * in Test static block upper
			in helper constructor
			in test32...
			in Test static block lower
			From test main
			in helper constructor3: pera
			Upper block Test
			Lower block Test
			ff
			yy

		  */
		 
		 //Exam.main(args);
		 /**
		  * Output:
		  * 
		  * in Test static block upper
			in helper constructor
			in test32...
			in Test static block lower
			From test main
			in Exam static block upper
			in helper constructor3: djura
			in Exam getObj...
			in Exam static block lower
			From Exam main
			in helper constructor3: pera
			Upper block Test
			Lower block Test
			ff
			yy
			in helper constructor2: 5
			Upper block Exam
			Lower block Exam
			No arg constructor Exam
			
			in helper constructor3: pera
			Upper block Test
			Lower block Test
			ff
			yy
			in helper constructor2: 5
			Upper block Exam
			Lower block Exam
			No arg constructor Exam

		  */
		 
		// new Exam();
		 /**
		  * 
		  * Output:
		  * 
		  * in Test static block upper
			in helper constructor
			in test32...
			in Test static block lower
			From test main
			in Exam static block upper
			in helper constructor3: djura
			in Exam getObj...
			in Exam static block lower
			in helper constructor3: pera
			Upper block Test
			Lower block Test
			ff
			yy
			in helper constructor2: 5
			Upper block Exam
			Lower block Exam
			No arg constructor Exam

		  */
	}
	 
	 {System.out.println("Lower block Test");}
	 
	 static { System.out.println("in Test static block lower");}
}

class Exam extends Test{
	
	 static {System.out.println("in Exam static block upper");}
	
	 private Helper h = new Helper(5);
	 {System.out.println("Upper block Exam");}
	 private static Helper h2 = new Helper("djura");
	 static Object x = getObj();
			 
			 
	 static Object getObj() {
		 System.out.println("in Exam getObj...");
		 return null;
	 }
	 
	 static {System.out.println("in Exam static block lower");}
	 
	 public Exam() {
		 super(1);
		 System.out.println("No arg constructor Exam");
	 }
	 
	 public static void main(String[] args) {
		 System.out.println("From Exam main");
		 new Exam();
		 System.out.println();
		 new Exam();
		 
	}
	{System.out.println("Lower block Exam");}
}

class Helper{
	
	public Helper() {
		System.out.println("in helper constructor");
	}
	
	public Helper(int i) {
		System.out.println("in helper constructor2: " + i);
	}
	
	public Helper(String x) {
		System.out.println("in helper constructor3: " + x);
	}
}


Example2:

public class Animal {
 static { System.out.print("A"); }
}
public class Hippo extends Animal {
 public static void main(String[] grass) {
 System.out.print("C");
 new Hippo();
 new Hippo();
 new Hippo();
 }
 static { System.out.print("B"); }
}

Why the Hippo Program Printed C After AB?

the Hippo class was initialized before the main() method was
executed. This happened because our main() method was inside the class being executed,
so it had to be loaded on startup

Example 3:

class GiraffeFamily {
	static { System.out.print("A"); }
	{ System.out.print("B"); }
	
	public GiraffeFamily(String name) {
		this(1);
		System.out.print("C");
	}
	
	 public GiraffeFamily() {
		 System.out.print("D");
	 }
	
	 public GiraffeFamily(int stripes) {
		 System.out.print("E");
	 }
 }
 public class Okapi extends GiraffeFamily {
	 static { System.out.print("F"); }
	
	 public Okapi(int stripes) {
		 super("sugar");
		 System.out.print("G");
	 }
	 
	 { System.out.print("H"); }
	
	 
	 public static void main(String[] grass) {
		 new Okapi(1);
		 System.out.println();
		 new Okapi(2);
	 }
 }


***Important rule: 

Unlike static class members, though, final instance fields can also be set in a constructor. The constructor is part of the initialization process, so it is allowed to assign final
instance variables. For the exam, you need to know one important rule: by the time the constructor completes, all final instance variables must be assigned a value exactly once.

public class MouseHouse {
 private final int volume;
 private final String name = "The Mouse House"; // Declaration assignment
  static final int test;
 {
 volume = 10; // Instance initializer assignment; DOES COMPILE
 }
 public MouseHouse() {
		test = 22; // DOES NOT COMPILE
		volume = 2; // DOES NOT COMPILE; already assigned in block
		
}
}

public class StaticFinalInstanceVariables {
	
	//non-final variable initialization
	private int x1 = 22;
	private int x;
	{x = 55;}
	static {
		//x = 22; //DOES NOT COMPILE
	}
	
	//final variable initialization
	private final int y = 22;
	private final int y1;
	private final int y3;
	//private final int y4; //final instance variables must be assigned a value If they are not assigned a value
    //when they are declared or in an instance initializer, then they must be assigned a value in
    //the constructor declaration. Failure to do so will result in a compiler error on the line that
    //declares the constructor
	//** by the time the constructor completes, all final instance variables must be assigned a value exactly once.
	static {
		//y = 224; //DOES NOT COMPILE; Cannot make a static reference to the non-static field y
		//y1 = 222; //DOES NOT COMPILE; Cannot make a static reference to the non-static field y1
	}
	{
		//y = 222; //DOES NOT COMPILE; already assigned
		y1 = 55; 
	    //y1 = 22; //DOES NOT COMPILE; already assigned value
	}
	
	
	//static variable initialization
	private static int c1; //non initialed at all; takes default value
	private static int c = 22;
	private static int c0;
	static {
		c = 225; //DOES COMPILE
		c0 = 22;
		c0 = 2222; //can be reassigned value
	}
	
	{c = 66; c0 = 22;} {c1 = 6622;} //DOES COMPILE ***Important in non-static block, static variable can be used
	
	
	//static final variable initialization
	private static final int s0;
	
	static {
		s0 = 2;
	}
	{
		//s0 = 2; //DOES NOT COMPILE; static-final cannot be initialized in non-static block
	}
	//** by the time the constructor completes, all final instance variables must be assigned a value exactly once.
	
	public StaticFinalInstanceVariables() { 
		
		x1 = 32; //DOES COMPILE
		x = 444; //DOES COMPILE
		
		//y = 22; //DOES NOT COMPILE; already assigned
		//y1 = 55; //DOES NOT COMPILE; The final field y1 may already have been assigned
		y3 = 22; //DOES COMPILE; it is not been assigned nowhere before constructor
		
		c = 23; //DOES COMPILE
		c0 = 22; //DOES COMPILE static and non-final variables can be initialized within blocks (static and non static) as well as constructors
		
		//s0 = 2; //DOES NOT COMPILE; static and final variables must be initialized either in-line or in static blocks; not allowed in constructors
	}
}


Initializing Classes

1. If there is a superclass Y of X, then initialize class Y first.
2. Process all static variable declarations in the order in which they appear in the class.
3. Process all static initializers in the order in which they appear in the class


Initializing Instances

Initialize Instance of X
1. Initialize class X if it has not been previously initialized.
2. If there is a superclass Y of X, then initialize the instance of Y first.
3. Process all instance variable declarations in the order in which they appear in the class.
4. Process all instance initializers in the order in which they appear in the class.
5. Initialize the constructor, including any overloaded constructors referenced with this().



We conclude this section by listing important rules you should know for the exam:
■ A class is initialized at most once by the JVM before it is referenced or used.
■ All static final variables must be assigned a value exactly once, either when they are declared or in a static initializer.
■ All final fields must be assigned a value exactly once, either when they are declared, in an instance initializer, or in a constructor.
■ Non-final static and instance variables defined without a value are assigned a default value based on their type.
■ Order of initialization is as follows: variable declarations, then initializers, and finally constructors.



--------------------------------------


Initializing final Fields with constructor compiler error


public class MouseHouse {
 private final int volume;
 private final String type;
 {
 this.volume = 10;
 }
 public MouseHouse(String type) {
 this.type = type;
 }
 public MouseHouse() { // DOES NOT COMPILE
 this.volume = 2; // DOES NOT COMPILE
 }
}

In this example, the first constructor that takes a String argument compiles. In terms
of assigning values, each constructor is reviewed individually, which is why the second constructor does not compile. 
First, the constructor fails to set a value for the type variable.
The compiler detects that a value is never set for type and reports an error on the line where
the constructor is declared. Second, the constructor sets a value for the volume variable,
even though it was already assigned a value by the instance initializer.


On the exam, be wary of any instance variables marked final. Make
sure they are assigned a value in the line where they are declared, in an
instance initializer, or in a constructor. They should be assigned a value
only once, and failure to assign a value is considered a compiler error in
the constructor


What about final instance variables when a constructor calls another constructor in the
same class? In that case, you have to follow the flow carefully, making sure every final instance variable is assigned a value exactly once. We can replace our previous bad constructor
with the following one that does compile:
 public MouseHouse() {
 this(null);
 }
This constructor does not perform any assignments to any final instance variables, but
it calls the MouseHouse(String) constructor, which we observed compiles without issue.

--------------------------------------

Overriding a Method

To override a method, you must follow a number of rules. The compiler performs the following checks when you override a method:

1. The method in the child class must have the same signature as the method in the parent class.
2. The method in the child class must be at least as accessible as the method in the parent class.
3. The method in the child class may not declare a checked exception that is new or broader than the class of any exception declared in the parent class method.
4. If the method returns a value, it must be the same or a subtype of the method in the parent class, known as covariant return types.

'same signature' - Remember that a method signature is composed of the name of the
method and method parameters. It does not include the return type,
access modifiers, optional specifiers, or any declared exceptions.

While these rules may seem confusing or arbitrary at first, they are needed for consistency.
Without these rules in place, it is possible to create contradictions within the Java language.

