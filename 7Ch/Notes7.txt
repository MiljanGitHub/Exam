
Classes, interfaces and abstract classes

Example1:

public class Interfaces {
	
	interface Fly{ //in every interface, methods are by default 'public abstract'
		void fly(); //same as in abstract methods in abstract classes, must have (param1, param2), no body with {} and must have ; at the end
		//'void fly();' is equivalent to 'public abstract void fly();'
	}
	
	interface Swim{
		void swim();
	}
	
	abstract class Animal{
		abstract CharSequence getType();
//		String getType() { //same method signature in abstract class; DOES NOT COMPILE
//			return null;
//		}
	}
	
	abstract class Bird extends Animal implements Fly{
		//Since it is an abstract class, no need to implement Fly interface, although we could, like so:
		public void fly() { //must be public; if it is not public, and we leave package-access level, we get DOES NOT COMPILE
							//since methods in interfaces have public access by default
			
			//super.getType() //DOES NOT COMPILE; not exists in super-class since it super-class is abstract
			
		} //we could comment this implementation and it would compile
		
		//public abstract Object fly(); //DOES NOT COMPILE; The return type is incompatible with Fly.fly()
		
		//abstract public void fly(); //DOES COMPILE ( as long as we have uncommented implementation of fly() ); but is not necessary thing to do; Cannot have 'abstract public void fly();' and 'public void fly() {...}' at the same time
		//abstract void fly(); //DOES NOT COMPILE; Reduced visibility from interface
		
		//abstract Object getType(); //DOES NOT COMPILE; Incompatible return type from superclass Animal
		
		abstract String getType(); //can have, but it also can be commented; same method as in super-abstract-class 'Animal'. This is some kind of 'override'. Same package access since this method is coming from a superclass not from a interface 
		
		//some other regular abstract method
		abstract boolean test();
		
		
		**Some conclusion on my own: if the compile figures out that METHOD SIGNATURE is matching from either a superclass or a interface, then it starts to apply rules for overriding, package access, return type etc...
		
	}
	
	class Swan extends Bird implements Swim{
		
		public boolean test(){
			return false;
		}
		
		String getType() {
			return null;
		}
		
		//public void fly() {}	//Commented method DOES COMPILE since we gave implementation for interface Fly.fly() in abstract superclass
		
		public void swim() {}	
	}
}



Example2:

public class Interfaces2 {
	
	public abstract interface CanBurrow { //'abstract' is an implicit modifier which compiler inserts into interface declaration
		 public abstract Number getSpeed(int age);
		 public static final int MINIMUM_DEPTH = 2;
	}
	
	public interface Climb {
		Float getSpeed(int age);
	}
	
	public class FieldMouse implements Climb, CanBurrow {
		public Float getSpeed(int age) {
			return 11f;
		} //one method implementation for two interfaces
	}
}


Example3:

public class Interfaces3 {
	public interface Nocturnal {
		 public int hunt();
	}
	public interface CanFly {
		 public void flap();
	}

	public interface HasBigEyes extends Nocturnal, CanFly {
		 public void flap(); //DOES COMPILE; it also compiles if we omit this line and leave empty {}
	}

	public class Owl implements HasBigEyes {
		 public int hunt() { return 5; }
		 public void flap() { System.out.println("Flap!"); }
	}
}

Example4:


public class Interfaces4 {
	public interface HasTail {
		 public int getTailLength();
		}
		public interface HasWhiskers {
		 public int getNumberOfWhiskers();
		}
		abstract class Test{
			abstract void t();
		}
		
		public abstract class HarborSeal extends Test implements HasTail, HasWhiskers {}
		
		public class CommonSeal extends HarborSeal {} // DOES NOT COMPILE
}

**The HarborSeal class compiles because it is abstract and not required to implement
any of the abstract methods it inherits or implements. The concrete CommonSeal class, though, must
override all inherited abstract methods.

Example5:

public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
public class Hyena2 {}
public interface HasFur2 implements Hyena2 {} // DOES NOT COMPILE


Example6:

public class Interfaces5 {
	//Example a:
//	public interface Herbivore { public void eatPlants(); }
//	public interface Omnivore { public void eatPlants(); }
//	
//	public class Bear implements Herbivore, Omnivore {
//
//		public void eatPlants() {
//			System.out.println("Eating plants");
//	 } 
//	}
	
	//Example b:
//	public interface Herbivore2 { public String eatPlants(); }
//	public interface Omnivore2 { public StringBuilder eatPlants(); } 	
//	
//	public class Horse implements Herbivore2, Omnivore2 {
//	
//		public CharSequence eatPlants() { //Question to ask to myself: "Is CharSequence a String??" or "Is CharSequence a StringBuilder??"
//			//Since answer is NO: ----> DOES NOT COMPILE
//			return null;
//	 }
//	}
	
	//Example c:
//	public interface Herbivore3 { public CharSequence eatPlants(); }
//	public interface Omnivore3 { public CharSequence eatPlants(); } 	
//	
//	public class Donkey implements Herbivore3, Omnivore3 {
//	
//		public String eatPlants() { //Question to ask to myself: "Is String a CharSequence??" or "Is StringBuilder a CharSequence??" - Compatible method ---> meaning, a method can be written that properly overrides both inherited
																																							  methods: for example, by using covariant return types that you learned about in Chapter 6
//			//Since answer is YES: ----> DOES COMPILE
//			return null;
//	 }
//	}

	//Example d:
	public interface Herbivore4 { public void eatPlants(); }
	public interface Omnivore4 { public int eatPlants(); }
	public class Tiger implements Herbivore4, Omnivore4 { // DOES NOT COMPILE - 
		//It’s impossible to write a version of Tiger that satisfies both inherited abstract
		//methods. The code does not compile, regardless of what is declared inside the Tiger class.
	}
}

Example7:

public class Interfaces6 {
	public interface Dance {
		 //private int count = 4; // DOES NOT COMPILE
		 //protected void step(); // DOES NOT COMPILE
		 *two compilation erros
		
		private static void test() { } // DOES COMPILE
		
		private  void test2() {}  // DOES COMPILE
		
	}
}


--------------------------------------

default Interface Method

A default method is a method defined in an interface with the default keyword
and includes a method body. It may be optionally overridden by a class implementing the
interface.

Example1:

 interface IsColdBlooded {
	 boolean hasScales();
	 default double getTemperature() {
		 return 10.0;
	 } 
}
public class Snake implements IsColdBlooded {

	 public boolean hasScales() { // Required override
		 return true;
	 }
	 
	 public double getTemperature() { // Optional override
		 return 12;
	 }
	 
	 public static void main(String[] args) {
		Snake s = new Snake();
		System.out.println(s.getTemperature());;
		//IsColdBlooded.getTemperature(); //DOES NOT COMPILE;  they are associated with the instance of the class implementing the interface.
	}
}

Example2:

TODO...Don't know what...

!!!Default Interface Method Definition Rules!!! 

1. A default method may be declared only within an interface.

public class Rule {
	
	public interface HasTail {}
	
	class Test implements HasTail{
		default void test(); //DOES NOT COMPILE
	}
}
	
	
2. A default method must be marked with the default keyword and include a method body.

public class Rule {
	
	public interface HasTail {
		//default void test(); //DOES NOT COMPILE
		default void test() {
			//DOES COMPILE
		}
	}
	class Test implements HasTail{
		
	}
}


3. A default method is implicitly public.

public class Rule {
	
	public interface HasTail {

		public default void test() {} //DOES COMPILE
		default void test2 () {} //DOES COMPILE
	}
}


4. A default method cannot be marked abstract, final, or static.

public class Rule {
	
	public interface HasTail {
		public abstract default void test3 () {} //DOES NOT COMPILE: Cannot be 'abstract' since they must have a body/("deafault")implementation Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public static default void test4 () {} //DOES NOT COMPILE: they are associated with the instance of the class implementing the interface. Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public final default void test3 () {} //DOES NOT COMPILE: they are designed so that they can be overridden in classes implementing the interface, just like abstract methods. 
	}

}


5. A default method may be overridden by a class that implements the interface.

*Example1 in this section, above

6. If a class inherits two or more default methods with the same method signature, then the class must override the method.

Exaplanation for Rule 6:

Inheriting Duplicate default Methods

The last rule for creating a default interface method requires some explanation. For example,
what value would the following code output?
public interface Walk {
 public default int getSpeed() { return 5; }
}
public interface Run {
 public default int getSpeed() { return 10; }
}
public class Cat implements Walk, Run {} // DOES NOT COMPILE
In this example, Cat inherits the two default methods for getSpeed(), so which does
it use? Since Walk and Run are considered siblings in terms of how they are used in the Cat
class, it is not clear whether the code should output 5 or 10. In this case, the compiler throws
up its hands and says, “Too hard, I give up!” and fails.
All is not lost, though. If the class implementing the interfaces overrides the duplicate
default method, the code will compile without issue. By overriding the conflicting method,
the ambiguity about which version of the method to call has been removed. For example, the
following modified implementation of Cat will compile:

public class Cat implements Walk, Run {
 public int getSpeed() { return 1; }
}

--------------------------------------

Calling a Hidden default Method


In the last section, we showed how our Cat class could override a pair of conflicting
default methods, but what if the Cat class wanted to access the version of getSpeed() in
Walk or Run? Is it still accessible?
Yes, but it requires some special syntax.
public class Cat implements Walk, Run {
 public int getSpeed() {
 return 1;
 }
 public int getWalkSpeed() {
 return Walk.super.getSpeed(); //Note that calling Walk.getSpeed() or Walk.this.getSpeed() would not have worked
							   //We use the interface name to indicate which method we want to call, but we
						       //use the super keyword to show that we are following instance inheritance, not class inheritance.
 } }


--------------------------------------

Declaring static Interface Methods




--------------------------------------