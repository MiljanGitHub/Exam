
Classes, interfaces and abstract classes

Example1:

public class Interfaces {
	
	interface Fly{ //in every interface, methods are by default 'public abstract'
		void fly(); //same as in abstract methods in abstract classes, must have (optional param1, param2), no body with {} and must have ; at the end
		//'void fly();' is equivalent to 'public abstract void fly();'
	}
	
	interface Swim{
		void swim();
	}
	
	abstract class Animal{
		abstract CharSequence getType();
//		String getType() { //same method signature in abstract class; DOES NOT COMPILE
//			return null;
//		}
	}
	
	abstract class Bird extends Animal implements Fly{
		//Since it is an abstract class, no need to implement Fly interface, although we could, like so:
		public void fly() { //must be public; if it is not public, and we leave package-access level, we get DOES NOT COMPILE
							//since methods in interfaces have public access by default
			
			//super.getType() //DOES NOT COMPILE; not exists in super-class since it super-class is abstract
			
		} //we could comment this implementation and it would compile
		
		//public abstract Object fly(); //DOES NOT COMPILE; The return type is incompatible with Fly.fly()
		
		//abstract public void fly(); //DOES COMPILE ( as long as we have uncommented implementation of fly() ); but is not necessary thing to do; Cannot have 'abstract public void fly();' and 'public void fly() {...}' at the same time
		//abstract void fly(); //DOES NOT COMPILE; Reduced visibility from interface
		
		//abstract Object getType(); //DOES NOT COMPILE; Incompatible return type from superclass Animal
		
		abstract String getType(); //can have, but it also can be commented; same method as in super-abstract-class 'Animal'. This is some kind of 'override'. Same package access since this method is coming from a superclass not from a interface 
		
		//some other regular abstract method
		abstract boolean test();
		
		
		**Some conclusion on my own: if the compile figures out that METHOD SIGNATURE is matching from either a superclass or a interface, then it starts to apply rules for overriding, package access, return type etc...
		
	}
	
	class Swan extends Bird implements Swim{
		
		public boolean test(){
			return false;
		}
		
		String getType() {
			return null;
		}
		
		//public void fly() {}	//Commented method DOES COMPILE since we gave implementation for interface Fly.fly() in abstract superclass
		
		public void swim() {}	
	}
}



Example2:

public class Interfaces2 {
	
	public abstract interface CanBurrow { //'abstract' is an implicit modifier which compiler inserts into interface declaration
		 public abstract Number getSpeed(int age);
		 public static final int MINIMUM_DEPTH = 2;
	}
	
	public interface Climb {
		Float getSpeed(int age);
	}
	
	public class FieldMouse implements Climb, CanBurrow {
		public Float getSpeed(int age) {
			return 11f;
		} //one method implementation for two interfaces
	}
}


Example3:

public class Interfaces3 {
	public interface Nocturnal {
		 public int hunt();
	}
	public interface CanFly {
		 public void flap();
	}

	public interface HasBigEyes extends Nocturnal, CanFly {
		 public void flap(); //DOES COMPILE; it also compiles if we omit this line and leave empty {}
	}

	public class Owl implements HasBigEyes {
		 public int hunt() { return 5; }
		 public void flap() { System.out.println("Flap!"); }
	}
}

Example4:


public class Interfaces4 {
	public interface HasTail {
		 public int getTailLength();
		}
		public interface HasWhiskers {
		 public int getNumberOfWhiskers();
		}
		abstract class Test{
			abstract void t();
		}
		
		public abstract class HarborSeal extends Test implements HasTail, HasWhiskers {}
		
		public class CommonSeal extends HarborSeal {} // DOES NOT COMPILE
}

**The HarborSeal class compiles because it is abstract and not required to implement
any of the abstract methods it inherits or implements. The concrete CommonSeal class, though, must
override all inherited abstract methods.

Example5:

public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
public class Hyena2 {}
public interface HasFur2 implements Hyena2 {} // DOES NOT COMPILE


Example6:

public class Interfaces5 {
	//Example a:
//	public interface Herbivore { public void eatPlants(); }
//	public interface Omnivore { public void eatPlants(); }
//	
//	public class Bear implements Herbivore, Omnivore {
//
//		public void eatPlants() {
//			System.out.println("Eating plants"); //DOES COMPILE
//	 } 
//	}
	
	//Example b:
//	public interface Herbivore2 { public String eatPlants(); }
//	public interface Omnivore2 { public StringBuilder eatPlants(); } 	
//	
//	public class Horse implements Herbivore2, Omnivore2 {
//	
//		public CharSequence eatPlants() { //Question to ask to myself: "Is CharSequence a String??" or "Is CharSequence a StringBuilder??"
//			//Since answer is NO: ----> DOES NOT COMPILE
//			return null;
//	 }
//	}
	
	//Example c:
//	public interface Herbivore3 { public CharSequence eatPlants(); }
//	public interface Omnivore3 { public CharSequence eatPlants(); } 	
//	
//	public class Donkey implements Herbivore3, Omnivore3 {
//	
//		public String eatPlants() { //Question to ask to myself: "Is String a CharSequence??" or "Is StringBuilder a CharSequence??" - Compatible method ---> meaning, a method can be written that properly overrides both inherited
																																							  methods: for example, by using covariant return types that you learned about in Chapter 6
//			//Since answer is YES: ----> DOES COMPILE
//			return null;
//	 }
//	}

	//Example d:
	public interface Herbivore4 { public void eatPlants(); }
	public interface Omnivore4 { public int eatPlants(); }
	public class Tiger implements Herbivore4, Omnivore4 { // DOES NOT COMPILE - 
		//It’s impossible to write a version of Tiger that satisfies both inherited abstract
		//methods. The code does not compile, regardless of what is declared inside the Tiger class.
	}
}

Example7:

public class Interfaces6 {
	public interface Dance {
		 //private int count = 4; // DOES NOT COMPILE
		 //protected void step(); // DOES NOT COMPILE
		 *two compilation erros
		private static void test() { } // DOES COMPILE
		private  void test2() {}  // DOES COMPILE
	}
}

Example8:
public interface A {
	default   void test(){
		System.out.println("a");
	}
}

public interface B extends A {}

public class Interfaces11 implements B{
	public static void main(String[] args) {
		new Interfaces11().test(); //DOES COMPILE
	}
}

Example9:

1: interface HasExoskeleton {
2: double size = 2.0f;
3: abstract int getNumberOfSections();
4: }
5: abstract class Insect implements HasExoskeleton {
6: abstract int getNumberOfLegs();
7: }
8: public class Beetle extends Insect { //This line DOES NOT COMPILE. try to figure out why??
9: int getNumberOfLegs() { return 6; }
10: int getNumberOfSections(int count) { return 1; }
11: }

Example10:

interface Aquatic {
    int getNumOfGills(int p);
}
public class ClownFish implements Aquatic {
    String getNumOfGills() { return "14"; }
    int getNumOfGills(int input) { return 15; } //This line DOES NOT COMPILE; comapare it with Example9
    public static void main(String[] args) {
        System.out.println(new ClownFish().getNumOfGills(-1));
    } }

--------------------------------------

default Interface Method

A default method is a method defined in an interface with the default keyword
and includes a method body. It may be optionally overridden by a class implementing the
interface.

Example1:

 interface IsColdBlooded {
	 boolean hasScales();
	 default double getTemperature() {
		 return 10.0;
	 } 
}
public class Snake implements IsColdBlooded {

	 public boolean hasScales() { // Required override
		 return true;
	 }
	 
	 public double getTemperature() { // Optional override
		 return 12;
	 }
	 
	 public static void main(String[] args) {
		Snake s = new Snake();
		System.out.println(s.getTemperature());;
		//IsColdBlooded.getTemperature(); //DOES NOT COMPILE;  they are associated with the instance of the class implementing the interface.
	}
}

Example2:

TODO...Don't know what...

!!!Default Interface Method Definition Rules!!! 

1. A default method may be declared only within an interface.

public class Rule {
	
	public interface HasTail {}
	
	class Test implements HasTail{
		default void test(); //DOES NOT COMPILE
	}
}
	
	
2. A default method must be marked with the default keyword and include a method body.

public class Rule {
	
	public interface HasTail {
		//default void test(); //DOES NOT COMPILE
		default void test() {
			//DOES COMPILE
		}
	}
	class Test implements HasTail{
		
	}
}


3. A default method is implicitly public.

public class Rule {
	
	public interface HasTail {

		public default void test() {} //DOES COMPILE
		default void test2 () {} //DOES COMPILE
	}
}


4. A default method cannot be marked abstract, final, or static.

public class Rule {
	
	public interface HasTail {
		public abstract default void test3 () {} //DOES NOT COMPILE: Cannot be 'abstract' since they must have a body/("deafault")implementation Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public static default void test4 () {} //DOES NOT COMPILE: they are associated with the instance of the class implementing the interface. Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public final default void test3 () {} //DOES NOT COMPILE: they are designed so that they can be overridden in classes implementing the interface, just like abstract methods. 
	}

}


5. A default method may be overridden by a class that implements the interface.

*Example1 in this section, above

6. If a class inherits two or more default methods with the same method signature, then the class must override the method.

Exaplanation for Rule 6:

Inheriting Duplicate default Methods

The last rule for creating a default interface method requires some explanation. For example,
what value would the following code output?
public interface Walk {
 public default int getSpeed() { return 5; }
}
public interface Run {
 public default int getSpeed() { return 10; }
}
public class Cat implements Walk, Run {} // DOES NOT COMPILE
In this example, Cat inherits the two default methods for getSpeed(), so which does
it use? Since Walk and Run are considered siblings in terms of how they are used in the Cat
class, it is not clear whether the code should output 5 or 10. In this case, the compiler throws
up its hands and says, “Too hard, I give up!” and fails.
All is not lost, though. If the class implementing the interfaces overrides the duplicate
default method, the code will compile without issue. By overriding the conflicting method,
the ambiguity about which version of the method to call has been removed. For example, the
following modified implementation of Cat will compile:

public class Cat implements Walk, Run {
 public int getSpeed() { return 1; }
}

--------------------------------------

Calling a Hidden default Method


In the last section, we showed how our Cat class could override a pair of conflicting
default methods, but what if the Cat class wanted to access the version of getSpeed() in
Walk or Run? Is it still accessible?
Yes, but it requires some special syntax.
public class Cat implements Walk, Run {
 public int getSpeed() {
 return 1;
 }
 public int getWalkSpeed() {
 return Walk.super.getSpeed(); //Note that calling Walk.getSpeed() or Walk.this.getSpeed() would not have worked
							   //We use the interface name to indicate which method we want to call, but we
						       //use the super keyword to show that we are following instance inheritance, not class inheritance.
 } }


--------------------------------------

Declaring static Interface Methods

Static Interface Method Definition Rules
1. A static method must be marked with the static keyword and include a method body.
2. A static method without an access modifier is implicitly public.
3. A static method cannot be marked abstract or final.
4. A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.

interface Test1{
	static void m() {} //static methods are not inherited like default
}

interface Test2{
	static void m() {}
}
interface Swim{
	//Rule1
	//public static void print(); //DOES NOT COMPILE; need body implementation
	
	//Rule2
	 static void print() {} //DOES COMPILE; equivalent to: 'public static void print(){}'
	 
	//Rule3
	// static abstract void print2() {} //DOES NOT COMPILE;
	// static final void print3() {} //DOES NOT COMPILE;
}

public class Interfaces7 implements Test1, Test2, Swim{ //can impl both Test1 and Test2 - Java “solved” the multiple inheritance problem of static interface methods by not allowing them to be inherited
	
	public static void main(String[] args) {
		//usage of static interface methods
		
		Swim.print(); //DOES COMPILE
		
		//print();  //DOES NOT COMPILE; even tho the class implements the interface
		
		Interfaces7 obj = new Interfaces7();
		//obj.print(); //DOES NOT COMPILE;
		
	}
}


--------------------------------------

Reusing Code with private Interface Methods

Example1:

public class Interfaces8 {
	
	interface Swim{
		
		default void print() {
			sm(); //DOES COMPILE
			print(); //DOES COMPILE - Stackoverflow/Recursion
			pr();  //DOES COMPILE
			test();  //DOES COMPILE
		}
		
		//Accessing static and non-static interface methods within a static interface method:
		static void sm() {
			//print(); //DOES NOT COMPILE
			Swim.sm(); //DOES COMPILE
			Swim s = null;
			Swim ss = new Swim() {
				public void test() {
					
				}
			};
			ss.sm(); //DOES NOT COMPILE
			//s.sm();  //DOES NOT COMPILE
			//test(); //DOES NOT COMPILE
			//pr();  //DOES NOT COMPILE
		}
		
		//Accessing static and non-static interface methods within a non-static private interface method:
		private void pr() {
			pr(); //DOES COMPILE
			Swim.sm(); //DOES COMPILE
			print();  //DOES COMPILE
			test();  //DOES COMPILE
			
			Swim sm = null;
			sm.print();  //DOES COMPILE - NPE
			
			Swim sm2 = null;
			sm2.test();   //DOES COMPILE - NPE
			
		}
		
		void test();
	}

}

Example2:

public class Interfaces9 {
	public interface Schedule {
		 default void wakeUp() { checkTime(7); test();}
		 private void haveBreakfast() { checkTime(9); test();}
		 static void workOut() { checkTime(18); }
		 
		 void test1();
		 
		 private void test() {
			 test1();
		 }
		 
		 private static void checkTime(int hour) {
			 if (hour> 17) {
				 System.out.println("You're late!");
			 } else {
				 System.out.println("You have "+(17-hour)+" hours left to make the appointment");
			 } 
			 
			 //test(); //DOES NOT COMPILE
			 workOut(); //DOES COMPILE
		 } 
	}
}

The difference between a non-static private method and a static one is analogous to the difference between an instance and static method declared within a class. In
particular, it’s all about what methods each can be called from.
Private Interface Method Definition Rules
1. A private interface method must be marked with the private modifier and include a method body.
2. A private static interface method may be called by any method within the interface definition.
3. A private interface method may only be called by default and other private nonstatic methods within the interface definition.

Another way to think of it is that a private interface method is only accessible to nonstatic methods defined within the interface. A private static interface method,  
on the other hand, can be accessed by any method in the interface. For both types of private
methods, a class inheriting the interface cannot directly invoke them.


Example3:

public interface ZooRenovation {
 public String projectName();
 abstract String status();
 default void printStatus() {
 System.out.print("The " + projectName() + " project " + status());
 } }
 
 
*It turns out default and private non-static methods can access abstract methods
declared in the interface. This is the primary reason we associate these methods with instance
membership.

--------------------------------------

Working with Enums

Example1:

public enum Season {
	WINTER, SPRING, SUMMER, FALL
}

Example2:

public class Enums1 {
	public enum Season {
		 WINTER, SPRING, SUMMER, FALL //; is optional 
	}
	
	public enum SeasonComplex {
		 WINTER(Season.WINTER); //; is mandatory 
		
		private SeasonComplex(Season s) {
			
		}
	}
	
	public static void main(String[] args) {
		Season[] x = Season.values();
	}
}


public enum Season { //only public or package-access
 WINTER, SPRING, SUMMER, FALL; //since this is a simple-enum, ; is OPTIONAL
} //this is so called 'simple-enum' -> only contains a list of values


var s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true


As you can see, enums print the name of the enum when toString() is called. They can
be compared using == because they are like 'static final' constants. In other words, you
can use equals() or == to compare enums, since EACH ENUM IS INITIALIZED ONLY ONCE in
the Java Virtual Machine (JVM).

Calling the values(), name(), and ordinal() Methods

values() ->  array of all of the values: Season[] x = Season.values();
for(var season: Season.values()) {
 System.out.println(season.name() + " " + season.ordinal());
}
WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t compare an int and an enum value directly anyway since an enum is a type, like a Java class, and not a primitive int.
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE


Season s = Season.valueOf("SUMMER"); // SUMMER 
//***Note that line above is
not creating an enum value, at least not directly. Each enum value is created once when the
enum is first loaded. Once the enum has been loaded, it retrieves the single enum value with
the matching name.

Season t = Season.valueOf("summer"); // IllegalArgumentException


Season summer = Season.SUMMER;
switch(summer) {
 case WINTER: // <- enums in switch statement must be noted as 'WINTER' not as  'Season.WINTER'
	System.out.print("Get out the sled!");
	break;
 case SUMMER:
	System.out.print("Time for the pool!");
	break;
 default:
	System.out.print("Is it summer yet?");
} //DOES COMPILE


Season summer = Season.SUMMER;
var message = switch(summer) {
 case Season.WINTER -> "Get out the sled!"; // DOES NOT COMPILE
 case 0 -> "Time for the pool!"; // DOES NOT COMPILE; pay attention
 default -> "Is it summer yet?";
};

Adding Constructors, Fields, and Methods

Example1:


public class Enums1 {
	
	
	public enum SeasonComplex {
		
		
		WINTER(Season.WINTER), SUMMER(Season.SUMMER), TEST(1), TEST2(""); //; is mandatory 
		//The part 'WINTER(Season.WINTER)' (and others) represent constructor call without a 'new' keyword
		
		//These "fake" constructor calls, must be first lines of the Enum file. Apparently these constructor call are made for JVM for initial initialization and assignment
		
		//The first time we ask for any of the enum values, Java constructs all of the enum values. After that, Java just returns the already constructed enum values.
		
		//if we try to add: ', TEST3(this.x1)' in as one more constructor call we get error: 'Cannot use 'this' in a static context'
		
		private  int x1;
		private  Season s; //if it is 'final' the it must be assigned a value either in a instance block or in a constructor (note: every constructor is considered for 'final' variables assignments on its own, i.e. if we or JVM calls any constructor, each 'final' variable must be assigned) 
		
		//SeasonComplex
		{s = null;} //DOES COMPILE
		
		private static String x = initX();
		{System.out.println("Upper block in SeasonComplex");}
		
		static {
			System.out.println("upper static in SeasonComplex");
		}
		
		private SeasonComplex(Season s) {
			System.out.println("Constructor with Season");
		}
		private SeasonComplex(int x) {
			System.out.println("Constructor with int");	
		}
		
		private SeasonComplex(String x) {
			System.out.println("Constructor with String");
		}
		
		private SeasonComplex(long x) { //we can have 'other' constructors 
			System.out.println("Constructor with long");
		}
		
		private SeasonComplex() {
			System.out.println("Constructor no-args");
		}
		
		//private SeasonComplex(int i) {this(555);} //DOES NOT COMPILE; recursive constructor
		//private SeasonComplex(int x) {} //DOES NOT COMPILE; Duplicate method
		
		public static void s() {}
		
		private static String initX(){
			System.out.println("initX called...");
			return "aa";
		}
		
		{System.out.println("Lower block in SeasonComplex");}
		static {
			System.out.println("Lower static in SeasonComplex");
		}
		
		 public void printExpectedVisitors() {
			System.out.println(x1);
		 }
	}
	
	public enum Season {
		 WINTER, SPRING, SUMMER, FALL; //; is optional if there is nothing in the enum (simple enum). If there is something, like instance block, then ; is mandatory 
		 {System.out.println("@ffff");}
		 
		
	}
	
	public static void main(String[] args) {
		Season[] x = Season.values();
		SeasonComplex[] s = SeasonComplex.values();
		SeasonComplex.SUMMER.s();

//		Season x = SeasonComplex.SUMMER.s; //even though 's' is private in a enum file it is still accessible in this manner
//		int y = SeasonComplex.TEST.x1; // even though 'x1' is private in a enum file it is still accessible in this manner
//		
//		int x1 = SeasonComplex.SUMMER.x1; //even though 'x1' is private in a enum file it is still accessible in this manner
//		Season y1 = SeasonComplex.TEST.s;  //even though 's' is private in a enum file it is still accessible in this manner
		
	}
}

Output:

@ffff
@ffff
@ffff
@ffff
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with Season
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with Season
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with int
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with String
initX called...
upper static in SeasonComplex
Lower static in SeasonComplex


***Interestingly, static members are eveluated last...

Example 2:


public enum OnlyOne {
 ONCE(true);
 private OnlyOne(boolean b) {
 System.out.print("constructing,");
 }
}
public class PrintTheOne {
 public static void main(String[] args) {
 System.out.print("begin,");
 OnlyOne firstCall = OnlyOne.ONCE; // Prints constructing,
 OnlyOne secondCall = OnlyOne.ONCE; // Doesn't print anything
 System.out.print("end");
 }
}

**If the OnlyOne enum was used earlier in the program, and therefore initialized sooner,
then the line that declares the firstCall variable would not print anything.


How do we call an enum method? That’s easy, too: we just use the enum value followed by the method call.
Season.SUMMER.printExpectedVisitors();

Example3:

public enum Season {
 WINTER {
 public String getHours() { return "10am-3pm"; }
 },
 SPRING {
 public String getHours() { return "9am-5pm"; }
 },
 SUMMER {
 public String getHours() { return "9am-7pm"; }
 },
 FALL {
 public String getHours() { return "9am-5pm"; }
 };
 public abstract String getHours();
}

Example3a:

public enum Season {
 WINTER {
 public String getHours() { return "10am-3pm"; }
 },
 SUMMER {
 public String getHours() { return "9am-7pm"; }
 },
 SPRING, FALL;
 public String getHours() { return "9am-5pm"; } //We only code the special cases and let the others use the enum-provided implementation
}

Example4:

public interface Weather { int getAverageTemperature(); }
public enum Season implements Weather {
 WINTER, SPRING, SUMMER, FALL;
 public int getAverageTemperature() { return 30; }
}

***This was not an accident. Whether the enum is simple
or complex, the list of values always comes first.

Example5:

public class Bear {
/*    enum FOOD {
        BERRIES,INSECTS {
            public boolean isHealthy() { return true; }
        },
        FISH, ROOTS, COOKIES, HONEY;
        public abstract boolean isHealthy(); //if the method is marked 'abstract' all enums MUST have implementation
    }*/ This DOES NOT COMPILE, implementation for INSECTS is only given!!!


/*    enum FOOD { 
        BERRIES{
            public boolean isHealthy() { return true; }
        },

        INSECTS {
            public boolean isHealthy() { return true; }
        },
        FISH{
            public boolean isHealthy() { return true; }
        }, ROOTS{
            public boolean isHealthy() { return true; }
        }, COOKIES{
            public boolean isHealthy() { return true; }
        }, HONEY{
            public boolean isHealthy() { return true; }
        };
        public abstract boolean isHealthy(); //if the method is marked 'abstract' all enums MUST have implementation
		
		//All DOES COMPILE, we have all the implementations
    }*/
	
/*   enum FOOD{
        TEST1, TEST2{
            
        };
        public boolean isHealthy(){
            return true;
        }
    }*/ This Enum DOES COMPILE; all enums are using default method
	
	
/*   enum FOOD{
        TEST1, TEST2{
            //DOES COMPILE
            public boolean isHealth2(){
                return false;
            }

            @Override //DOES COMPILE
            public boolean isHealthy(){
                return false;
            }
        }, TEST3{}, TEST4;   //DOES COMPILE; ';' mandatory

        
        public boolean isHealthy(){
            return true;
        }
		
		private FOOD(){ } //DOES COMPILE
        public FOOD(){ } //DOES NOT COMPILE

    } //FROM ENUM
	
*/
	
	
	
}

***Exam will be try to tricky you with usage of semi-colons only with Enums


--------------------------------------

Sealing Classes


Sealing allows classes and interfaces to define their permitted subtypes.
In other words, a class or an interface can now define which classes can implement or extend it. It is a useful feature for domain modeling and increasing the security of libraries.


 having restricted subclasses should not limit the accessibility of its superclass.
Thus, the main motivation behind sealed classes is to have the possibility for a superclass to be widely accessible but not widely extensible.

***sealed -> Indicates that a class or interface may only be extended/implemented by named classes or interfaces

***permits -> Used with the sealed keyword to list the classes and interfaces allowed

***non-sealed -> Applied to a class or interface that extends a sealed class, indicating that it can be extended by unspecified classes

Example1:

public class sealed Frog permits GlassFrog {} // DOES NOT COMPILE; 'sealed' must be before 'class' keyword
public final class GlassFrog extends Frog {}

Example2:

public abstract sealed class Wolf permits Timber {} // DOES COMPILE; can be abstract; Sealed classes are commonly declared with the abstract modifier, although this is certainly not required
public final class Timber extends Wolf {}
public final class MyWolf extends Wolf {} // DOES NOT COMPILE; MyWolf is not defined in the 'permits' list of the Wolf class; The type MyWolf extending a sealed class Wolf should be a permitted subtype of Wolf

Example3:

***a sealed class needs to be declared (and compiled) in the same package as its direct subclasses.
//Bear1.java
 package sealed;
 import sealed.test.Kodiak1;
 import sealed.test.Panda1;
 public sealed class Bear1 permits Kodiak1, Panda1 {} //DOES NOT COMPILE: Permitted type Kodiak1 in an unnamed module should be declared in the same package sealed of declaring type Bear1
 																	      Permitted type Panda1 in an unnamed module should be declared in the same package sealed of declaring type Bear1
 //Kodiak1.java
  package sealed.test;
  import sealed.Bear1;
  public final class Kodiak1 extends Bear1 {}  //DOES COMPILE 
  
 //Panda1.java
  package sealed.test;
  import sealed.Bear1;
  public non-sealed class Panda1 extends Bear1 {}  //DOES COMPILE 


Example4:

But what about the subclasses themselves?
They must each extend the sealed class. 

//Penguin.java
package test3;

public sealed class Penguin permits Emperor {} // DOES NOT COMPILE; Permitted class Emperor does not declare test3.Penguin as direct super class

//Emperor.java
package sealed.test3;

public final class Emperor {}

***Specifying the Subclass Modifier
While some types, like interfaces, have a certain number of implicit modifiers, sealed classes
do not. Every class that directly extends a sealed class must specify exactly one of the following three modifiers: final, sealed, or non-sealed. Remember this rule for the exam!



Modifier1: 'final'

public sealed class Antelope permits Gazelle {}
public final class Gazelle extends Antelope {}
public class George extends Gazelle {} // DOES NOT COMPILE


Modifier2: 'sealed'

public sealed class Mammal permits Equine {}
public sealed class Equine extends Mammal permits Zebra {}
public final class Zebra extends Equine {}

The sealed modifier applied to the subclass Equine means the same kind of rules that
we applied to the parent class Mammal must be present. Namely, Equine defines its own list
of permitted subclasses. Notice in this example that Zebra is an indirect subclass of Mammal
but is not named in the Mammal class


Modifier3: 'non-sealed'

The non-sealed modifier is used to open a sealed parent class to potentially unknown subclasses.

public sealed class Wolf permits Timber {}
public non-sealed class Timber extends Wolf {}
public class DummyWolf extends Timber {}

then this is allowed: public class MyFurryWolf extends DummyWolf {}

Example5:

// Snake.java -> This is regular way of doing:
public sealed class Snake permits Cobra {}
final class Cobra extends Snake {} 

// Snake.java 
public sealed class Snake { //omits 'permits' keyword
	public static void main(String args[]) {
		System.out.print("D"); //print D
	}
}
final class Cobra extends Snake {} 

If we had two files:

// Snake.java
public sealed class Snake {}
final class Cobra extends Snake {}
If these classes were in separate files, this code would not compile! 
// Snake.java
public sealed class Snake {
 final class Cobra extends Snake {}
}

Example6:

Previous rule also applies to sealed classes with nested subclasses.

// Snake.java
public sealed class Snake {
	public static void main(String args[]) {
	 	System.out.print("D");	 //prints D
	}
 	final class Cobra extends Snake {} //nested subclass; DOES COMPILE
}

However, if we try to use 'permits' in this example:

public sealed class Snake permits Cobra{ // DOES NOT COMPILE; it must be written as 'public sealed class Snake permits Snake.Cobra{...}'
	public static void main(String args[]) {
	 	System.out.print("D");	 
	}
 	final class Cobra extends Snake {} //nested subclass
}
**When all of your subclasses are nested, we strongly recommend omitting the
permits class.




Usage of the permits clause in sealed classes:

Location of direct subclasses 										permits clause

In a different file from the sealed class 						    Required
In the same file as the sealed class 								Permitted, but not required
Nested inside of the sealed class 									Permitted, but not required


Sealing Interfaces


One distinct feature of a sealed interface is that the 'permits' list can apply to a class that
implements the interface or an interface that extends the interface.
// Sealed interface
public sealed interface Swims permits Duck, Swan, Floats {} //with intefaces in 'permits', we can mix classES (which impl 'sealed' interface) and other interfaces (which extend 'sealed' interface)

// Classes permitted to implement sealed interface
public final class Duck implements Swims {}
public final class Swan implements Swims {}

// Interface permitted to extend sealed interface
public non-sealed interface Floats extends Swims {}

***
What about the modifier applied to interfaces that extend the sealed interface? Well,
remember that interfaces are implicitly abstract and cannot be marked final. For
this reason, interfaces that extend a sealed interface can only be marked sealed or
non-sealed. They cannot be marked final.

Sealed Class Rules:

Any time you see a sealed class on the exam, pay close attention to the subclass declaration
and modifiers.

■ Sealed classes are declared with the sealed and permits modifiers.
■ Sealed classes must be declared in the same package or named module as their direct subclasses.
■ Direct subclasses of sealed classes must be marked final, sealed, or non-sealed.
■ The permits clause is optional if the sealed class and its direct subclasses are declared within the same file or the subclasses are nested within the sealed class.
■ Interfaces can be sealed to limit the classes that implement them or the interfaces that extend them.
■ Iterfaces that extend a sealed interface can only be marked sealed or non-sealed. They cannot be marked final.


Example7:

package sealed;
//TraficLight.java

public sealed interface TraficLight{}

final class RedLight implements TraficLight{}

sealed class YellowLight implements TraficLight{} //with first three lines it DOES NOT COMPILE; 
												//reason: YellowLight (sealed) must have a class which extends it (that is, its a 'permits' list, inserted by a compiler, must not be empty. And since we are in a single file we just need to define a inheriting class):
												//Sealed class or interface lacks the permits clause and no class or interface from the same compilation unit declares YellowLight as its direct superclass or super-interface
												
final class SpecialYellowLight extends YellowLight{} //DOES COMPILE

Example8:

public class DemoSealed {

    sealed class Bird { //DOES COMPILE
        public final class Flamingo extends Bird {}
    }
    sealed class Monkey {}  //DOES COMPILE; no need for 'permits' clause since we are in a single file
    class EmperorTamarin extends Monkey {} //DOES NOT COMPILE; must have any of the modifiers 'final', 'sealed' or 'non-sealed'

    non-sealed class Mandrill extends Monkey {}  //DOES COMPILE; Since it is 'non-sealed' it can be extended by any other class

    sealed class Friendly extends Mandrill permits Silly {} //DOES NOT COMPILE because of the line bellow
    final class Silly{} //This line on its own DOES COMPILE, however, since it is in the 'permits' list of Friendly, then Friendly is the one that does not compile


    //If for instance we omitted 'permits Silly', then again Friendly would not compile because no one is extending Friendly
}

Some TRUE/FALSE facts on sealed classes/interfaces:


A. A sealed interface restricts which subinterfaces may extend it. - TRUE
B. A sealed class cannot be indirectly extended by a class that is not listed in its permits clause. - FALSE
C. A sealed class can be extended by an abstract class. - TRUE
D. A sealed class can be extended by a subclass that uses the nonsealed modifier. - FALSE
E. A sealed interface restricts which subclasses may implement it. - TRUE
F. A sealed class cannot contain any nested subclasses. - FALSE

--------------------------------------

Records

*Records cannot be inherited because of 'final'; not they can be extended

public record Crane(int numberEggs, String name) {}

is equivalent to:

public final class Crane {

	private final int numberEggs;
	private final String name;
	
	public Crane(int numberEggs, String name) {
		this.numberEggs = numberEggs; 
		this.name = name;
	}
	public int numberEggs() { // getter
		return numberEggs;
	}
	public String name() { // getter
		return name;
	}
 }

Crane c = new Crane(2, "");
c.numberEggs();
c.name();

*A record is a special type of data-oriented class in which the compiler inserts boilerplate code for you.
In fact, the compiler inserts much more than the 14 lines we wrote earlier. As a bonus, the
compiler inserts useful implementations of the Object methods equals(), hashCode() and toString().

Behind the scenes, it creates a constructor for you with the parameters in the same order in which they appear in
the record declaration. Omitting or changing the type order will lead to compiler errors:
var mommy1 = new Crane("Cammy", 4); // DOES NOT COMPILE
var mommy2 = new Crane("Cammy"); // DOES NOT COMPILE

public record Crane() {} //DOES COMPILE


In order to “modify” a record, you have to make a new object and copy all of the data you want to preserve.

var cousin = new Crane(3, "Jenny");
var friend = new Crane(cousin.numberEggs(), "Janeice");

public final record Crane(int numberEggs, String name) {} //DOES COMPILE

public record BlueCrane() extends Crane {} // DOES NOT COMPILE

public record Crane(int numberEggs, String name) extends A{} // DOES NOT COMPILE

class TestA extends Crane{ // DOES NOT COMPILE

    public TestA(int numberEggs, String name) {
        super(numberEggs, name);
    }
}

public interface Bird {}
public record Crane(int numberEggs, String name) implements Bird {} //DOES COMPILE

Declaring Constructors (long and compact):

What if you need to declare a record with some guards as we did earlier?

The Long Constructor

First, we can just declare the constructor the compiler normally inserts automatically, which we refer to as the long constructor.

public record Crane(int numberEggs, String name) {
 public Crane(int numberEggs, String name) {
	if (numberEggs < 0) throw new IllegalArgumentException();
	this.numberEggs = numberEggs;
	this.name = name;
 }
}

The compiler will not insert a constructor if you define one with the same list of parameters in the same order. 
Since each field is final, the constructor must set every field. For example, this record does not compile:

In other words, if we have a constructor whose signature is the same as the one that is in record's declaration, the we will get compiler error, provided that there is no compact constructor and no assignment of final fields inside that constructor
If we, however, do have compact constructor then it takse precedence and it is it (the compact constructor) which is converted to record's constructor declaration.

public record Crane(int numberEggs, String name) {
 public Crane(int numberEggs, String name) {} // DOES NOT COMPILE; no assignment of final fields
}

Example a:

public record Crane(int numberEggs, String name) {
	 public Crane(int numberEggs, String name) { // DOES  COMPILE; our custom constructor; MUST follow order of parameters in a record declaration, BOTH types and parameter names
		 if (numberEggs < 0) throw new IllegalArgumentException();
		 this.numberEggs = numberEggs;
		 this.name = name;
	 }
}

Example b:

public record Crane(int numberEggs, String name) {
	
	 public Crane(int numberEggs, String a) { //DOES NOT COMPILE; invalid parameter names in canonical constructor
		 if (numberEggs < 0) throw new IllegalArgumentException();
		 this.numberEggs = numberEggs;
		 this.name = a;
	 }
}

Example c:

public record Crane(int numberEggs, String name) {

    public Crane(int numberEggs, String name) { //our custom constructor;
        if (numberEggs < 0) throw new IllegalArgumentException();
        this.numberEggs = numberEggs;
        this.name = name;
    }

    public Crane(String name, int numberEggs) { //DOES NOT COMPILE
        this.numberEggs = numberEggs;
        this.name = name;
    }
}

Example d:

public record Crane(int numberEggs, String name) {

    public Crane(int numberEggs, String name) { //our custom constructor;
        if (numberEggs < 0) throw new IllegalArgumentException();
        this.numberEggs = numberEggs;
        this.name = name;
    }

    public Crane(String name) { //DOES COMPILE
        this(-1, null);
    }
}


Compact Constructors

Java calls the full constructor after the compact constructor but with the modified constructor parameters. Acutally, comapct constructor is converted to a primary constructor

Example a:

Compact constructor serves only for validation/transformation of the data, it then implicitly calls default Java-generated constructor. We cannot have that default constructor written manaully insteda of Java,
Java has to do it.

public record Crane(int numberEggs, String name) {
	
	 public Crane(int numberEggs, String name) { 
		 this.numberEggs = numberEggs;
		 this.name = name;
	 }
	 
	 public Crane { // DOES NOT COMPILE since we have defined a regular constructor
		 if (numberEggs < 0) throw new IllegalArgumentException();
		 numberEggs = 999;
		 name = name.toUpperCase();
		 
		 //*** note that 'numberEggs' and 'name' are reffering to local variables not on instance variables
		 //***Note there is no () after 'public Crane'
	}
}



Example b:

You can manipulate only certain fields, no need to touch other fields i.e. local variables which will later be asigned to instance variables in default constructor


public record Crane(int numberEggs, String name) {
	 
	public Crane {
		 numberEggs = 999;
	}
}

Example c:

Cannot have multiple compact constructors

public record Crane(int numberEggs, String name) {

	public Crane {
		numberEggs = 999;
	}
	 
	public Crane { //DOES NOT COMPILE;  constructor Crane(int,String) is already defined in record Crane
		numberEggs = 123;
	}
}

Example d:

While compact constructors can modify the constructor parameters, they cannot modify the fields of the record. For example, this does not compile:

public record Crane(int numberEggs, String name) {
 public Crane {
 this.numberEggs = 10; // DOES NOT COMPILE
 }
}

Overloaded Constructors

Example a: ***Tricky example

public record Crane(int numberEggs, String name) {
	

	public Crane(String firstName, String lastName) {
		
		this(0, firstName + " " + lastName);
		System.out.println("Overloaded constructor completed");
	}
	
	public Crane {
		System.out.println("Inside compact constructor");
		numberEggs = 999;
		if (true) {
			numberEggs = 22; //DOES COMPILE since we are modifying constructor parameters
		}
	}
	
	public static void main(String[] args) {
		Crane c = new Crane("A", "B");
		System.out.println(c);
//		Inside compact constructor
//		Overloaded constructor completed
//		Crane[numberEggs=22, name=A B]
	}
}

Example b:

public record Crane(int numberEggs, String name) {
 public Crane(String firstName, String lastName) {
	this(0, firstName + " " + lastName); // DOES COMPILE
 }
}

Example c:

public record Crane(int numberEggs, String name) {
	 public Crane(String firstName, String lastName) {
		 this();
	 }
	 
	 public Crane() {
		 this(0, "asd");
		 numberEggs = 1; //DOES NOT COMPILE; The final field numberEggs may already have been assigned
		 //Since we are not in compact constructor, Java thinks we are touching instance variable, which are already assigned...
	 }
}

Example d:

public record  Crane2(int numberEggs, String name) {
    
    public Crane2(){
        this(0, "a");
    }

    public Crane2(int x){
        this(0, "a");
    }

    public Crane2{
        numberEggs = 22;
        name = "aaa";
    }

    public static void main(String[] args) {
        new Crane2(1, "aaaafff");
    }
}
//DOES COMPILE

Example e:


public record  Crane2(int numberEggs, String name) {

    public Crane2(){
        this(0, "a");
    }

    public Crane2(int x){
        this();
    }

    public Crane2{
        numberEggs = 22;
        name = "aaa";
    }

    public static void main(String[] args) {
        new Crane2(1, "aaaafff");
    }
}

//DOES COMPILE

Example f:

public record Crane(int numberEggs, String name) {
 public Crane(int numberEggs, String firstName, String lastName) {
	this(numberEggs + 1, firstName + " " + lastName);
	numberEggs = 10; // NO EFFECT (applies to parameter, not instance field)
	this.numberEggs = 20; // DOES NOT COMPILE; instance var already assigned
 }
}

Example g:

public record Crane(int numberEggs, String name) {
 public Crane(String name) {
 this(1); // DOES NOT COMPILE
 }
 public Crane(int numberEggs) {
 this(""); // DOES NOT COMPILE
 }
}

Example h:

public record Crane(int numberEggs, String name) {
	public Crane(int numberEggs, String name) { // DOES NOT COMPILE
		
	} 
	
	 public Crane{ // DOES NOT COMPILE; two construcotrs with same signature
		numberEggs = 1;
		name = "";
	}
}

Example j:

public record  Crane2(int numberEggs, String name) {

    public Crane2(){
        this(0, "a");
    }

    public Crane2(int x){
        this();
    }

    public Crane2{
        numberEggs = 22;
        name = "aaa";
    }
	
    /*
    If no compact constructor is used in source file (commented) then this is a constructor which is created:

    public Crane2(int numberEggs, String name) {
        this.numberEggs = numberEggs;
        this.name = name;
    }

    If we do have compact constructor, then this is a constructor which is created:
    
    public Crane2(int numberEggs, String name) {
        numberEggs = 22; // 'overriding'/gazim ulazne konstruktor parametre
        name = "aaa"; // 'overriding'/gazim ulazne konstruktor parametre
        this.numberEggs = numberEggs;
        this.name = name;
    }
    */

    public static void main(String[] args) {
        new Crane2(1, "aaaafff"); //Everything COMPILES
    }
}

Example i:

public record Crane(int numberEggs, String name) {
    private static int type = 10; //DOES COMPILE
    public int size; // DOES NOT COMPILE
    private boolean friendly; // DOES NOT COMPILE
	 
	public static void t(){  //DOES COMPILE
        System.out.println("ss");
    }

    
	{
        System.out.println("@");  // DOES NOT COMPILE
    }
	
    public Crane { 
        numberEggs = 999;
    }
	
	 static { //DOES COMPILE
        System.out.println("aaa");
    }
}

Example j:

public record BeardedDragon(boolean fun) {
 @Override public boolean fun() { return false; } //DOES COMPILE
 @Override public boolean equals(Object obj) { return false; } //DOES COMPILE; sam as for hashCode toString()
} 

--------------------------------------

Nested Classes

A nested class is a class that is defined within another class. A nested class can come in one of four flavors:
■ Inner class: A non-static type defined at the member level of a class
■ Static nested class: A static type defined at the member level of a class
■ Local class: A class defined within a method body
■ Anonymous class: A special case of a local class that does not have a name
*All four types of nested classes can now define static variables and methods!!!!!!!!!!!!!!!!!!!!!!


1. An Inner Class

An inner class, also called a member inner class, is a non-static type defined at the member
level of a class (the same level as the methods, instance variables, and constructors). Because
they are not top-level types, they can use any of the four access levels, not just public and
package access.

Inner classes have the following properties:
■ Can be declared public, protected, package, or private
■ Can extend a class and implement interfaces
■ Can be marked abstract or final
■ Can access members of the outer class, including private members

Example1:

public class Inner1 {
	
	private int x1 = 2;
	
	class InnerPackage{}
	
	private class InnerPrivate implements SomeInterface{}
	
	public final class InnerPublic{}
	
	protected abstract class InnerProtected{
		private int t = x1;
		
		void test() {
			System.out.println(x)1;
		}
	}
}


Example2:

public class Home {
    private String greeting = "Hi"; // Outer class instance variable
    private static String greeting2 = "Hi";
   
    protected class Room { // Inner class declaration
        public int repeat = 3;
        public void enter() {
            for (int i = 0; i < repeat; i++) greet(greeting);
			System.out.println(greeting2); //inner non-static member can access static member of enclosing class
        }
        private static void greet(String message) {
            System.out.println(message);
			System.out.println(greeting); //inner static member cannot access non-static member of enclosing class; in static method you cannot touch non-static members

        }
    }

    public void enterRoom() { // Instance method in outer class
	     Home.Room R = new Room();  //DOES  COMPILE
        Home.Room R1 = new Home.Room(); //DOES  COMPILE
		
        var room = new Room(); // Create the inner class instance
        room.enter();
		System.out.println(repeat); //DOES NOT COMPILE; Enclosing class cannot access inner class memeber even tho they are public; vice-reverese is possible
    }
    public static void main(String[] args) {
	    //Home.Room R = new Room(); //DOES NOT COMPILE, cannot be referenced from a static context
        var home = new Home(); // Create the outer class instance
        home.enterRoom();
    } 
}


Example3:

//different way of creating nested inner class
20: public static void main(String[] args) {
21: 	var home = new Home();
22: 	Room room = home.new Room(); // Create the inner class instance
23: 	room.enter();
24: }

We can’t just call new Room() inside the static main() method, because Java won’t
know which instance of Home it is associated with. Java solves this by calling new as if it
were a method on the room variable

Example4:

public class A {
    private int x = 10;
    class B extends A{
        private int x = 20;
        class C extends  B{
            private int x = 30;
            public void allTheX() {
             
                System.out.println(C.B.this.x);
                System.out.println(C.super.x);
                System.out.println(A.this.x);
                System.out.println(B.this.x);
                System.out.println(C.B.super.x);
            } } }
    public static void main(String[] args) {
        A a = new A();
        A.B b = a.new B();
        A.B.C c = b.new C();
        c.allTheX();
    }}

Example5:

public class A {
    private int x = 10;
    class B {
        private int x = 20;
        class C {
            private int x = 30;
            public void allTheX() {
                System.out.println(x); // 30
                System.out.println(this.x); // 30
                System.out.println(B.this.x); // 20
                System.out.println(A.this.x); // 10
                
            } } }
    public static void main(String[] args) {
        A a = new A();
        A.B b = a.new B(); //or:  'B bb = a.new B();' but DOES NOT COMPILE as:  'B b1 = new B();' 
							//new B() inside the static main() method, Java won’t know which instance of B it is associated with. 
							//Java solves this by calling 'new' as if it were a method on the 'a' variable
        A.B.C c = b.new C();  //or B.C c1 = b.new C(); but DOES NOT COMPILE as: C c2 = b.new C(); //their explanation: C is too deep for Java to know where to look.
        c.allTheX();
    }}

Example6:

//Fox.java
public class Fox {

    private class Den {}

    public void goHome() {
        new Den();
    }
    public static void visitFriend() {
        new Den(); // DOES NOT COMPILE
    }
}

//MainTest.java
public class MainTest {

    public static void main(String[] args) {
        Fox f = new Fox();

        final Fox.Den den = f.new Den(); //DOES NOT COMPILE, if it was public as: 'public class Den {}', then it would compile
    }
}

The line 'private class Den {}' must be observed as a member of a class Fox, such as methods and instance variables. In this case it is not a static member, so 
if we want to access that member ('private class Den {}') from some other static member (such as main()), that won't be allowed. We have to do either of three things:
1. remove 'static' from 'public static void visitFriend() {..}'
2. make Den class static
3. or within 'public static void visitFriend() {...}' create an instance of Fox class and refere to 'new Den' as if it (private class Den {}') is a member of Fox
	public static void visitFriend() {
        new Fox().new Den(); // DOES COMPILE
    }
	This would work since we are in Fox class and Den is a private member

Example7:

public class Fox {
    private class Den {}
}

public class Squirrel {
    public void visitFox() {
		new Den(); // DOES NOT COMPILE
        new Fox().new Den(); // DOES NOT COMPILE
    }
}

Constructor call does not compile for two reasons. Even though it is an instance method (visitFox()), it is not an instance method inside the Fox class. Adding a Fox reference
would not fix the problem entirely, though. Den is private and not accessible in the Squirrel class.

Example7:

Accessing private member in Inner classes (expansion of point 4. from the properties of Inner classes from above)

Simple example 7a:

public class K {
    private  int x;
    public static void main(String[] args) {
	    System.out.println(x);  //DOES NOT COMPILE
        final int x1 = new K().x; //DOES COMPILE
    }
}
class  Test2{
    public static void main(String[] args) {
        final K k = new K();
        System.out.println(k.x); //DOES NOT COMPILE
    }
}


Example 7b:

public class Home {
    private String greeting = "Hi"; // Outer class instance variable
    private static String greeting2 = "Hi";
	
    protected class Room { // Inner class declaration
        public int repeat = 3;
        private String a;
		void test(){
			System.out.println(greeting); //They refere to this example when they say that Inner classes can have access to private members of enclosing class
		}
    }
	
    public static void main(String[] args) {

        var home = new Home(); // Create the outer class instance
        final String a = home.new Room().a; //DOES COMPILE; since we are in the enclosing class: my explanation: 'accessing private member of a protected member is OK' while we are in enclosing class
        home.enterRoom();
    }
}

class X{

    void h(){
        final Home.Room room = new Home().new Room();
        System.out.println(room.a); //DOES NOT COMPILE; since we are not in the enclosing class: my explanation: 'accessing private member of a protected member is NOT OK' since we are not in enclosing class
    }
}

**if Roome was declared as 'private class Room {...}' then: 'final Home.Room room = new Home().new Room();' would not compile

Example8:

public abstract class Elephant {
 abstract private class SleepsAlot { //DOES COMPILE
 abstract int sleep();
 } }



2. Creating a static Nested Class

A static nested class is a static type defined at the member level. Unlike an inner class, 
a static nested class can be instantiated "directly" inside a static member(method) of an enclosing class, without an instance of the enclosing class. 


The trade-off, though, is that it can’t access instance variables or methods declared in the outer class.


public class Home2 {
    private  String greeting = "Hi"; // Outer class instance variable

    protected static class Room { // Inner class declaration
        public  int repeat = 3;
        public void enter() {
            for (int i = 0; i < repeat; i++) greet(greeting); //DOES NOT COMPILE; static-nested classes cannot access members of enclosing class, if they are not static
        }
        private static void greet(String message) {
            System.out.println(message);
        }
    }

    public void enterRoom() { // Instance method in outer class
        var room = new Room(); // Create the inner class instance
        room.enter();

    }
    public static void main(String[] args) {
        Room room = new Room(); //inside static method of an enclosing class, we don't need an instance of enclosing class to
                                //instantiate static-nested class
								
        var home = new Home2(); //Careful:
        home.new Room(); //We CANNOT create static-nested class instance via instance of enclosing class
    }
}

Example8:

public class Enclosing {

    public static class A{}

    private static class C{ }

    static class B{}
    protected static class D{}
    
    public static void main(String[] args) {
        //all DOES COMPILE
    }
}


Example9:

Static-nested classes cannot access members of an enclosing class

public class Enclosing {

    private int x;
    private static int x1;

    protected static class D{

        private int x;

        void m1(){
            System.out.println(x1); //DOES COMPILE
        }

        private void m(){
            //System.out.println(x); //DOES NOT COMPILE
        }
        
        void accessMethodFromOuterClass(){
            m5(); //DOES NOT COMPILE
            m5static();  //DOES  COMPILE
        }
    }
    public static void m5static(){
        
    }
    public void m5(){
        //accessing members of static-nested class while we are in enclosing class
        final int x2 = new D().x;  //DOES COMPILE
        new D().m(); //DOES COMPILE

    }

    public static void main(String[] args) {
        //accessing members of static-nested class while we are in enclosing class in static member
        final int x2 = new D().x;  //DOES COMPILE
        new D().m(); //DOES COMPILE
		new D().t(); //DOES COMPILE; warning is given, since we are accessing static member via instance of a class
        D.t(); //DOES COMPILE; no warning
		
    }
}

Example10:

public class Park {
    static class Ride {
        private int price = 6;
    }
    public static void main(String[] args) {
        var ride = new Ride();
        System.out.println(ride.price); //DOES COMPILE
    } }

Example11:

public class Lion {
    class Cub {}

    static class Den {}
    
    void methodWhichDoesntMatterIfItIsStaticOrNonStatic(){
        //Two ways how to create nested static class within en enclosing class!!! ***************
        var d = new Den();
        Lion.Den g = new Lion.Den();
    }
    

    void noStaticRest(){
        // Cub a = Lion.new Cub(); //DOES NOT COMPILE;
       // Lion.Cub b = new Lion().Cub(); //DOES NOT COMPILE;
        Lion.Cub c = new Lion().new Cub();  //DOES COMPILE;

        var d = new Den(); //DOES  COMPILE;

        //var e = Lion.new Cub(); //DOES NOT COMPILE;
        Lion.Den g = new Lion.Den();  //DOES  COMPILE;

        var h = new Cub();  //DOES  COMPILE;
    }

    static void rest() {

        //Cub a = Lion.new Cub(); //DOES NOT COMPILE; Cub is not a static member

        //Lion.Cub b = new Lion().Cub(); //DOES NOT COMPILE; missing 'new' before Cub() and after '.'

        Lion.Cub c = new Lion().new Cub(); //DOES  COMPILE; Correctly creates an instance of an inner class Cub using an instance of the outer class Lion.

        var d = new Den(); //DOES  COMPILE; correctly create an instance of the static nested Den class, which does not require an instance of Lion

        //var e = Lion.new Cub(); //DOES NOT COMPILE;

        // Lion.Den f = Lion.new Den(); //DOES NOT COMPILE; Even tho Den is a static member, in order to create it we must use instance of Lion as in 'new Lion'.Den();' and not as stated in example

        Lion.Den g = new Lion.Den(); //DOES  COMPILE; correctly create an instance of the static nested Den class, which does not require an instance of Lion
                                    // If we were to use 'new Lion().new Den();' that would NOT COMPILE; Den is static, and does not need an instance 'new'

       //var h = new Cub();  //DOES NOT COMPILE;

    }
}


3. A Local Classes


A local class is a nested class defined within a method. Like local variables, a local class declaration does not exist until the method is invoked, and it goes out of scope when the
method returns. This means you can create instances only from within the method. Those instances can still be returned from the method. This is just how local variables work. 
Local classes are not limited to being declared only inside methods. For example, they can be declared inside constructors and initializers. 


Example11:

public class Local {

    private int x;
	
	{
        static class F{} //DOES NOT COMPILE
    }
	
	public Local{
		class T{ }  //DOES  OMPILE
	
	}


	{
         class H{ }  //DOES  OMPILE
    }

    {
        interface H{ } //DOES  OMPILE
    }
	
	
	static {
        class K{ } //DOES  OMPILE
    }
	
    void m(){

        private class A{} //DOES NOT COMPILE
        protected class B{} //DOES NOT COMPILE
        public class C{} //DOES NOT COMPILE

        final class D{} //DOES  OMPILE
        abstract class E{} //DOES COMPILE
		class R{}  //DOES COMPILE
    }
}


Example12:

public class Local {
    private int x;
    private void m1(){ }

    void m(){

        final int g = 5;
        int r = 32;
        int h = 66;
        if (true) r = 444;

         class E{
             //private int f = r; // DOES NOT COMPILE
             private int x1 = h;  //DOES COMPILE
             private int x2 = g;

             void m(){
                 System.out.println(g); //DOES COMPILE
                 System.out.println(x); //DOES COMPILE
                 m1(); //DOES COMPILE
             }

             public E(){
                 m1(); //DOES COMPILE
             }
         }
    }
}

Example13:

public void processData() {
 final int length = 5;
 int width = 10;
 int height = 2;
 class VolumeCalculator {
	public int multiply() {
		return length * width * height; // DOES NOT COMPILE; 'width' is not effecitivly final
	}
 }
 width = 2;
}



Example14:

public class Local {
    private int x;
    private void m1(){ }


    public Tester getT(){ // DOES NOT COMPILE;
        class Tester{}
        final Tester tester = new Tester();
        return tester; // DOES NOT COMPILE;
    }

}


Example15:

If you declare the local class in a method, it can access the method's parameters.
 
public class Local {
    private int x;
	private static int y;
    public void m1(String x){
       
        interface A{  }
		
        class Student implements A{
            public Student(){
                System.out.println(x); //from m1 parameter
				 System.out.println(y); //DOES COMPILE
            }
        }
    }
}

Example16:

public class Local {
    private int x;
    private static int y;

    {
        class Teacher{
            void m(){
                System.out.println(x);  //DOES COMPILE
                System.out.println(y); //DOES COMPILE
            }
        }
    }


    private void m1(String x) {
        interface A {}
        class Student implements A {
            private static int x1;

            public Student() {
                //constructor
                System.out.println(x); //Local class defined in an instance method can access enclosing instance members from constructor
                System.out.println(y); //Local class defined in an instance method can access enclosing static instance members from constructor
            }

            public void t1() {
                System.out.println(x); //DOES COMPILE
            }

            public static void t2() {
                System.out.println(x);  //DOES NOT COMPILE; cannot access static members of enclosing class
            }
        }
    }
}


--------------------------------------

An Anonymous Classes


An anonymous class is a specialized form of a local class that does not have a name. It is
declared and instantiated all in one statement using the new keyword, a type name with
parentheses, and a set of braces {}. Anonymous classes must extend an existing class or
implement an existing interface. They are useful when you have a short implementation that
will not be used anywhere else.

Example1:

1: public class ZooGiftShop {
2: abstract class SaleTodayOnly {
3: 	abstract int dollarsOff();
4: }
5: public int admission(int basePrice) {
6: 		SaleTodayOnly sale = new SaleTodayOnly() { //Notice () and after it {...}
7: 			int dollarsOff() { return 3; }
8:		 }; // Don't forget the semicolon!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! We are declaring a local variable on thes lines. 
9: 	return basePrice - sale.dollarsOff();
10: } 
11: }

Example2:

1: public class ZooGiftShop {
2: 	interface SaleTodayOnly {
3: 		int dollarsOff();
4: 	}
5: public int admission(int basePrice) {
6: 	SaleTodayOnly sale = new SaleTodayOnly() {
7: 		public int dollarsOff() { return 3; } //Line 7 is public instead of using default access since interfaces require public methods.
8: 	};
9: 	return basePrice - sale.dollarsOff();
10: } 
11: }

Example3:

public class Gorilla {
 interface Climb {}
 Climb climbing = new Climb() {}; //Notice {}
}


Example4:

 public void sayHello() {
	abstract class HungarianGreeting{
       public HungarianGreeting(int i){}
       protected abstract void hi();
    }
	
	HungarianGreeting hg = new HungarianGreeting(666666){
       public void hi(){
           System.out.println("Miklos...");
       }
    };
    hg.hi();
 }


Example5:

public class Gorilla {
    private int k;
    interface Climb {}
    Climb climbing = new Climb() {
		int y  = k; //DOES COMPILE
        void m2(){
            System.out.println(k); //DOES COMPILE
        }
    }; //Notice {}
    
    void m(){
        interface Hi{}
        
        Hi h = new Hi() {
            
            void m1(){
                System.out.println(k); //DOES COMPILE
            }
        };
        
    }
}


Example6:

public class Ghost {
    public static void boo() {
        System.out.println("Not scared");
    }
    protected  class Spirit {
        public void boo() {
            System.out.println("Booo!!!");
        }
    }

    public static void main(String... haunt) {
        var g = new Ghost().new Spirit() {}; //DOES COMPILE; if Spirit was 'final' then it would not compile
    }

}



--------------------------------------


Understanding Polymorphism

Java object may be accessed using:

1. A reference with the same type as the object

	SameType st = new SameType();

2. A reference that is a superclass of the object

	SuperType sst = new SameType();
	 
	Also: SuperType  x = reference //DOES COMPILE and no need for casting if 'reference' is pointing to a subclass
		  Interface  x1 =  reference //DOES COMPILE and no need for casting if 'reference' is implementing an Interface
		  
3. A reference that defines an interface the object implements or inherits

	Interface x = new SameType();


Demo Example:

public class Primate {
 public boolean hasHair() {
	return true;
 }
}

public interface HasTail {
 public abstract boolean isTailStriped();
}

public class Lemur extends Primate implements HasTail {

 public boolean isTailStriped() {
	return false;
 }
 
 public int age = 10;
 
 public static void main(String[] args) {
	Lemur lemur = new Lemur();
	System.out.println(lemur.age);
	HasTail hasTail = lemur;
	System.out.println(hasTail.isTailStriped());
	Primate primate = lemur; //Question: Is lemur a primate? Yes -> DOES COMPILE
	System.out.println(primate.hasHair());
 } 

}


One instance created. Polymorphism enables an instance of Lemur to be reassigned or passed to a method using one of its supertypes, such as Primate or HasTail.

Once the object has been assigned to a new reference type, only the methods and variables available to that reference type are callable on the object without an explicit cast.

HasTail hasTail = new Lemur();
System.out.println(hasTail.age); // DOES NOT COMPILE
Primate primate = new Lemur();
System.out.println(primate.isTailStriped()); // DOES NOT COMPILE

Object vs. Reference
In Java, all objects are accessed by reference, so as a developer you never have direct access to the object itself. Conceptually, though, you should consider the object as the entity
that exists in memory, allocated by the Java Runtime Environment. Regardless of the type of the reference you have for the object in memory, the object itself doesn’t change. 
For example, since all objects inherit java.lang.Object, they can all be reassigned to java.lang.Object, as shown in the following example:
Lemur lemur = new Lemur();
Object lemurAsObject = lemur;

*******Even though the Lemur object has been assigned to a reference with a different type, the object itself has not changed and still exists as a Lemur object in memory. 
What has changed, then, is our ability to access methods within the Lemur class with the lemurAsObject reference. Without an explicit cast back to Lemur, as you see in the next section, we no longer
have access to the Lemur properties of the object.

We can summarize this principle with the following two rules:

1. The type of the object determines which properties exist within the object in memory. (If that 'concrete' object is a Lemur then all that Lemur contains can be found inside that object in memory)
2. The type of the reference to the object determines which methods and variables are accessible to the Java program. - Self explanatory

Casting Objects

Lemur lemur = new Lemur(); 
Primate primate = lemur; // Implicit Cast to supertype -> We are going from "narrower" to a "broader" type as they are refering to hierarchy of Exception classes;
														  Actually, W
Lemur lemur2 = (Lemur)primate; // Explicit Cast to subtype -> For this to work we need casting to a subtype. Because othervise, we need to ask ourselfs a question: "Is 'primate' a Lemur?" Answer is NO, "Lemur is a primate"
															  Always look bottom-up direction. Since answer is No, we need a (good and correct) cast.
															  if primitive was (pointing to actual object in memory) something else rather then a Lemur or any of its subclasses, then we would got ClassCastException.
															  When casting objects, you do not need a cast operator if casting to an inherited supertype. Since 'primate' variable is poiting to Primate 
															  whose inherited supertype is not Lemur but it is Object, the we need a cast.
Lemur lemur3 = primate; // DOES NOT COMPILE (missing cast)

We summarize these concepts into a set of rules for you to memorize for the exam:
1. Casting a reference from a subtype to a supertype doesn’t require an explicit cast.
2. ************Casting a reference from a supertype to a subtype requires an explicit cast.!!!!!!!!!!!!!!!!!!!!!!!!!!
3. At runtime, an invalid cast of a reference to an incompatible type results in a ClassCastException being thrown.
4. The compiler disallows casts to unrelated types

Disallowed Casts

public class Bird {}
public class Fish {
 public static void main(String[] args) {
 Fish fish = new Fish();
 Bird bird = (Bird)fish; // DOES NOT COMPILE; Class not related; PAY ATTENTION !!!!!!!!!!!!
 }
}

Casting with Interfaces


While the compiler can enforce rules about casting to unrelated types for classes, it cannot
always do the same for interfaces. Remember, interfaces support multiple inheritance, which
limits what the compiler can reason about them. While a given class may not implement an
interface, it’s possible that some subclass may implement the interface.


Example1:

interface At{}
interface A1{}
interface B extends At, A1{} //interfaces support multiple inheritance

interface C{}
interface G{}
class Primate{}
class Ape implements B{}
class Monkey extends Ape {}
class Orangutan extends Monkey implements B, C{}

public class PolyClass {

    public static void main(String[] args) {
        Monkey m = new Monkey();
        Ape ape = m; //monkey-ja mozes da stavis u Ape bez cast-a jer "Monkey is an Ape"
        B b =  ape; //ape mozes da stavis u B bez cast-a jer Ape implementira B
        B b2 = m; //monkey-ja mozes da stavis u B jer Ape implementira B, a "Monkey is an Ape"


        Orangutan o = new Orangutan();
        Monkey om = o;
        C cc = (C) om;

        G g = (G) o; //because of interfaces support for multiple inheritance, 'o' might be actually referring to any subclass which does implements G, so compiler cannot deduce it right away
                    // and does allow to compile, be we get ClassCastException at runtime
    }
}

**** The compiler does not allow a cast from an interface reference to an object reference if the object
type cannot possibly implement the interface, such as if the class is marked final (Example 2 and 3)

Example2:

interface R{}
class Person implements R{}
class Dad{}

		Person rp = new Person();
        R r = rp;
        Dad d = (Dad) rp; //DOES NOT COMPILE; inconvertible type;

Example3:


		
		
interface T{}
interface G{}
final class Primate implements G{} 

    Primate p = new Primate();
    T t0 = (T) p; //DOES NOT COMPILE; inconvertible type; Compiler starts thinking: 
				  //"Oh okay, here is a casting to interface type, I must allowe that, since some of Primate's subclass (which 'p' might be reffering to) might implement T. 
				 //But wait! Primate DOES NOT HAVE a subclass, since it is marked 'final', so there are not subclass which might implement G, in that cass I will say it DOES NOT COMPILE!
	T t1 = (T) new Primate(); //DOES NOT COMPILE; because of the bad syntax



Example4:

class Person{}
class Dad{}

Person rodent = new Person();
var capybara = (Dad)rodent; //DOES NOT COMPILE; unrelated classes

The instanceof Operator

Example1:

public class Bird {}
public class Fish {
 public static void main(String[] args) {
 Fish fish = new Fish();
 if (fish instanceof Bird b) { // DOES NOT COMPILE
 // Do stuff
 }
 }
}

Polymorphism and Method Overriding

Example 1:

class Penguin {
    public int getHeight() { return 3; }
    public void printInfo() {
        System.out.print(this.getHeight());
    }
}
public class EmperorPenguin extends Penguin {
    public int getHeight() { return 8; }
    public static void main(String []fish) {
        new EmperorPenguin().printInfo(); //8
    }
}

**Calling getHeight() on the object, calls the method associated with the precise object in memory, not the current
reference type where it is called. Even using the this reference, which is optional in this
example, does not call the parent version because the method has been replaced

-Polymorphism’s ability to replace methods at runtime via overriding is one of the most important properties of Java.


Overriding vs. Hiding Members


Example 1:

Unlike method overriding, hiding members is very sensitive to the reference type and location where the member is being used.

class Penguin {
 public static int getHeight() { return 3; }
 public void printInfo() {
 System.out.println(this.getHeight()); //in non-static method we can access static methods even by using 'this' //BUT it DOES ISSUES A WARNING 
 }
}
public class CrestedPenguin extends Penguin {
 public static int getHeight() { return 8; }
 public static void main(String... fish) {
 new CrestedPenguin().printInfo(); //3; 'this.getHeight()' now reffers to static method in parents class since static method cannot be overridden, they can be hidden
 }
}

Example2:

Reference type can also determine the value you get when you are working with hidden members:

class Marsupial {
    protected int age = 2;
    public static boolean isBiped() {
        return false;
    } }
public class Kangaroo extends Marsupial {
    protected int age = 6;
    public static boolean isBiped() {
        return true;
    }
    public static void main(String[] args) {
        Kangaroo joey = new Kangaroo();
        Marsupial moey = joey;
        System.out.println(joey.isBiped());
        System.out.println(moey.isBiped());
        System.out.println(joey.age);
        System.out.println(moey.age);
    } }

Output:	
true
false
6
2

Java uses the reference type to determine which version of isBiped() should be called


Example3:

the following program print?
1: class Person {
2:   static String name;
3:   void setName(String q) { name = q; } }
4: public class Child extends Person {
5:    static String name;
6:    void setName(String w) { name = w; }
7:    public static void main(String[] p) {
8: 		final Child m = new Child();
9: 		final Person t = m;
10: 	m.name = "Elysia";
11: 	t.name = "Sophia";
12: 	m.setName("Webby");
13: 	t.setName("Olivia");
14:		 System.out.println(m.name + " " + t.name);
15:   } 
16:  }







