
Classes, interfaces and abstract classes

Example1:

public class Interfaces {
	
	interface Fly{ //in every interface, methods are by default 'public abstract'
		void fly(); //same as in abstract methods in abstract classes, must have (optional param1, param2), no body with {} and must have ; at the end
		//'void fly();' is equivalent to 'public abstract void fly();'
	}
	
	interface Swim{
		void swim();
	}
	
	abstract class Animal{
		abstract CharSequence getType();
//		String getType() { //same method signature in abstract class; DOES NOT COMPILE
//			return null;
//		}
	}
	
	abstract class Bird extends Animal implements Fly{
		//Since it is an abstract class, no need to implement Fly interface, although we could, like so:
		public void fly() { //must be public; if it is not public, and we leave package-access level, we get DOES NOT COMPILE
							//since methods in interfaces have public access by default
			
			//super.getType() //DOES NOT COMPILE; not exists in super-class since it super-class is abstract
			
		} //we could comment this implementation and it would compile
		
		//public abstract Object fly(); //DOES NOT COMPILE; The return type is incompatible with Fly.fly()
		
		//abstract public void fly(); //DOES COMPILE ( as long as we have uncommented implementation of fly() ); but is not necessary thing to do; Cannot have 'abstract public void fly();' and 'public void fly() {...}' at the same time
		//abstract void fly(); //DOES NOT COMPILE; Reduced visibility from interface
		
		//abstract Object getType(); //DOES NOT COMPILE; Incompatible return type from superclass Animal
		
		abstract String getType(); //can have, but it also can be commented; same method as in super-abstract-class 'Animal'. This is some kind of 'override'. Same package access since this method is coming from a superclass not from a interface 
		
		//some other regular abstract method
		abstract boolean test();
		
		
		**Some conclusion on my own: if the compile figures out that METHOD SIGNATURE is matching from either a superclass or a interface, then it starts to apply rules for overriding, package access, return type etc...
		
	}
	
	class Swan extends Bird implements Swim{
		
		public boolean test(){
			return false;
		}
		
		String getType() {
			return null;
		}
		
		//public void fly() {}	//Commented method DOES COMPILE since we gave implementation for interface Fly.fly() in abstract superclass
		
		public void swim() {}	
	}
}



Example2:

public class Interfaces2 {
	
	public abstract interface CanBurrow { //'abstract' is an implicit modifier which compiler inserts into interface declaration
		 public abstract Number getSpeed(int age);
		 public static final int MINIMUM_DEPTH = 2;
	}
	
	public interface Climb {
		Float getSpeed(int age);
	}
	
	public class FieldMouse implements Climb, CanBurrow {
		public Float getSpeed(int age) {
			return 11f;
		} //one method implementation for two interfaces
	}
}


Example3:

public class Interfaces3 {
	public interface Nocturnal {
		 public int hunt();
	}
	public interface CanFly {
		 public void flap();
	}

	public interface HasBigEyes extends Nocturnal, CanFly {
		 public void flap(); //DOES COMPILE; it also compiles if we omit this line and leave empty {}
	}

	public class Owl implements HasBigEyes {
		 public int hunt() { return 5; }
		 public void flap() { System.out.println("Flap!"); }
	}
}

Example4:


public class Interfaces4 {
	public interface HasTail {
		 public int getTailLength();
		}
		public interface HasWhiskers {
		 public int getNumberOfWhiskers();
		}
		abstract class Test{
			abstract void t();
		}
		
		public abstract class HarborSeal extends Test implements HasTail, HasWhiskers {}
		
		public class CommonSeal extends HarborSeal {} // DOES NOT COMPILE
}

**The HarborSeal class compiles because it is abstract and not required to implement
any of the abstract methods it inherits or implements. The concrete CommonSeal class, though, must
override all inherited abstract methods.

Example5:

public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
public class Hyena2 {}
public interface HasFur2 implements Hyena2 {} // DOES NOT COMPILE


Example6:

public class Interfaces5 {
	//Example a:
//	public interface Herbivore { public void eatPlants(); }
//	public interface Omnivore { public void eatPlants(); }
//	
//	public class Bear implements Herbivore, Omnivore {
//
//		public void eatPlants() {
//			System.out.println("Eating plants"); //DOES COMPILE
//	 } 
//	}
	
	//Example b:
//	public interface Herbivore2 { public String eatPlants(); }
//	public interface Omnivore2 { public StringBuilder eatPlants(); } 	
//	
//	public class Horse implements Herbivore2, Omnivore2 {
//	
//		public CharSequence eatPlants() { //Question to ask to myself: "Is CharSequence a String??" or "Is CharSequence a StringBuilder??"
//			//Since answer is NO: ----> DOES NOT COMPILE
//			return null;
//	 }
//	}
	
	//Example c:
//	public interface Herbivore3 { public CharSequence eatPlants(); }
//	public interface Omnivore3 { public CharSequence eatPlants(); } 	
//	
//	public class Donkey implements Herbivore3, Omnivore3 {
//	
//		public String eatPlants() { //Question to ask to myself: "Is String a CharSequence??" or "Is StringBuilder a CharSequence??" - Compatible method ---> meaning, a method can be written that properly overrides both inherited
																																							  methods: for example, by using covariant return types that you learned about in Chapter 6
//			//Since answer is YES: ----> DOES COMPILE
//			return null;
//	 }
//	}

	//Example d:
	public interface Herbivore4 { public void eatPlants(); }
	public interface Omnivore4 { public int eatPlants(); }
	public class Tiger implements Herbivore4, Omnivore4 { // DOES NOT COMPILE - 
		//It’s impossible to write a version of Tiger that satisfies both inherited abstract
		//methods. The code does not compile, regardless of what is declared inside the Tiger class.
	}
}

Example7:

public class Interfaces6 {
	public interface Dance {
		 //private int count = 4; // DOES NOT COMPILE
		 //protected void step(); // DOES NOT COMPILE
		 *two compilation erros
		private static void test() { } // DOES COMPILE
		private  void test2() {}  // DOES COMPILE
	}
}

Example8:
public interface A {
	default   void test(){
		System.out.println("a");
	}
}

public interface B extends A {}

public class Interfaces11 implements B{
	public static void main(String[] args) {
		new Interfaces11().test(); //DOES COMPILE
	}
}


--------------------------------------

default Interface Method

A default method is a method defined in an interface with the default keyword
and includes a method body. It may be optionally overridden by a class implementing the
interface.

Example1:

 interface IsColdBlooded {
	 boolean hasScales();
	 default double getTemperature() {
		 return 10.0;
	 } 
}
public class Snake implements IsColdBlooded {

	 public boolean hasScales() { // Required override
		 return true;
	 }
	 
	 public double getTemperature() { // Optional override
		 return 12;
	 }
	 
	 public static void main(String[] args) {
		Snake s = new Snake();
		System.out.println(s.getTemperature());;
		//IsColdBlooded.getTemperature(); //DOES NOT COMPILE;  they are associated with the instance of the class implementing the interface.
	}
}

Example2:

TODO...Don't know what...

!!!Default Interface Method Definition Rules!!! 

1. A default method may be declared only within an interface.

public class Rule {
	
	public interface HasTail {}
	
	class Test implements HasTail{
		default void test(); //DOES NOT COMPILE
	}
}
	
	
2. A default method must be marked with the default keyword and include a method body.

public class Rule {
	
	public interface HasTail {
		//default void test(); //DOES NOT COMPILE
		default void test() {
			//DOES COMPILE
		}
	}
	class Test implements HasTail{
		
	}
}


3. A default method is implicitly public.

public class Rule {
	
	public interface HasTail {

		public default void test() {} //DOES COMPILE
		default void test2 () {} //DOES COMPILE
	}
}


4. A default method cannot be marked abstract, final, or static.

public class Rule {
	
	public interface HasTail {
		public abstract default void test3 () {} //DOES NOT COMPILE: Cannot be 'abstract' since they must have a body/("deafault")implementation Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public static default void test4 () {} //DOES NOT COMPILE: they are associated with the instance of the class implementing the interface. Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public final default void test3 () {} //DOES NOT COMPILE: they are designed so that they can be overridden in classes implementing the interface, just like abstract methods. 
	}

}


5. A default method may be overridden by a class that implements the interface.

*Example1 in this section, above

6. If a class inherits two or more default methods with the same method signature, then the class must override the method.

Exaplanation for Rule 6:

Inheriting Duplicate default Methods

The last rule for creating a default interface method requires some explanation. For example,
what value would the following code output?
public interface Walk {
 public default int getSpeed() { return 5; }
}
public interface Run {
 public default int getSpeed() { return 10; }
}
public class Cat implements Walk, Run {} // DOES NOT COMPILE
In this example, Cat inherits the two default methods for getSpeed(), so which does
it use? Since Walk and Run are considered siblings in terms of how they are used in the Cat
class, it is not clear whether the code should output 5 or 10. In this case, the compiler throws
up its hands and says, “Too hard, I give up!” and fails.
All is not lost, though. If the class implementing the interfaces overrides the duplicate
default method, the code will compile without issue. By overriding the conflicting method,
the ambiguity about which version of the method to call has been removed. For example, the
following modified implementation of Cat will compile:

public class Cat implements Walk, Run {
 public int getSpeed() { return 1; }
}

--------------------------------------

Calling a Hidden default Method


In the last section, we showed how our Cat class could override a pair of conflicting
default methods, but what if the Cat class wanted to access the version of getSpeed() in
Walk or Run? Is it still accessible?
Yes, but it requires some special syntax.
public class Cat implements Walk, Run {
 public int getSpeed() {
 return 1;
 }
 public int getWalkSpeed() {
 return Walk.super.getSpeed(); //Note that calling Walk.getSpeed() or Walk.this.getSpeed() would not have worked
							   //We use the interface name to indicate which method we want to call, but we
						       //use the super keyword to show that we are following instance inheritance, not class inheritance.
 } }


--------------------------------------

Declaring static Interface Methods

Static Interface Method Definition Rules
1. A static method must be marked with the static keyword and include a method body.
2. A static method without an access modifier is implicitly public.
3. A static method cannot be marked abstract or final.
4. A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.

interface Test1{
	static void m() {} //static methods are not inherited like default
}

interface Test2{
	static void m() {}
}
interface Swim{
	//Rule1
	//public static void print(); //DOES NOT COMPILE; need body implementation
	
	//Rule2
	 static void print() {} //DOES COMPILE; equivalent to: 'public static void print(){}'
	 
	//Rule3
	// static abstract void print2() {} //DOES NOT COMPILE;
	// static final void print3() {} //DOES NOT COMPILE;
}

public class Interfaces7 implements Test1, Test2, Swim{ //can impl both Test1 and Test2 - Java “solved” the multiple inheritance problem of static interface methods by not allowing them to be inherited
	
	public static void main(String[] args) {
		//usage of static interface methods
		
		Swim.print(); //DOES COMPILE
		
		//print();  //DOES NOT COMPILE; even tho the class implements the interface
		
		Interfaces7 obj = new Interfaces7();
		//obj.print(); //DOES NOT COMPILE;
		
	}
}


--------------------------------------

Reusing Code with private Interface Methods

Example1:

public class Interfaces8 {
	
	interface Swim{
		
		default void print() {
			sm(); //DOES COMPILE
			print(); //DOES COMPILE - Stackoverflow/Recursion
			pr();  //DOES COMPILE
			test();  //DOES COMPILE
		}
		
		//Accessing static and non-static interface methods within a static interface method:
		static void sm() {
			//print(); //DOES NOT COMPILE
			Swim.sm(); //DOES COMPILE
			Swim s = null;
			//s.sm();  //DOES NOT COMPILE
			//test(); //DOES NOT COMPILE
			//pr();  //DOES NOT COMPILE
		}
		
		//Accessing static and non-static interface methods within a non-static private interface method:
		private void pr() {
			pr(); //DOES COMPILE
			Swim.sm(); //DOES COMPILE
			print();  //DOES COMPILE
			test();  //DOES COMPILE
			
			Swim sm = null;
			sm.print();  //DOES COMPILE - NPE
			
			Swim sm2 = null;
			sm2.test();   //DOES COMPILE - NPE
			
		}
		
		void test();
	}

}

Example2:

public class Interfaces9 {
	public interface Schedule {
		 default void wakeUp() { checkTime(7); test();}
		 private void haveBreakfast() { checkTime(9); test();}
		 static void workOut() { checkTime(18); }
		 
		 void test1();
		 
		 private void test() {
			 test1();
		 }
		 
		 private static void checkTime(int hour) {
			 if (hour> 17) {
				 System.out.println("You're late!");
			 } else {
				 System.out.println("You have "+(17-hour)+" hours left to make the appointment");
			 } 
			 
			 //test(); //DOES NOT COMPILE
			 workOut(); //DOES COMPILE
		 } 
	}
}

The difference between a non-static private method and a static one is analogous to the difference between an instance and static method declared within a class. In
particular, it’s all about what methods each can be called from.
Private Interface Method Definition Rules
1. A private interface method must be marked with the private modifier and include a method body.
2. A private static interface method may be called by any method within the interface definition.
3. A private interface method may only be called by default and other private nonstatic methods within the interface definition.

Another way to think of it is that a private interface method is only accessible to nonstatic methods defined within the interface. A private static interface method,  
on the other hand, can be accessed by any method in the interface. For both types of private
methods, a class inheriting the interface cannot directly invoke them.


Example3:

public interface ZooRenovation {
 public String projectName();
 abstract String status();
 default void printStatus() {
 System.out.print("The " + projectName() + " project " + status());
 } }
 
 
*It turns out default and private non-static methods can access abstract methods
declared in the interface. This is the primary reason we associate these methods with instance
membership.

--------------------------------------

Working with Enums

Example1:

public enum Season {
	WINTER, SPRING, SUMMER, FALL
}

Example2:

public class Enums1 {
	public enum Season {
		 WINTER, SPRING, SUMMER, FALL //; is optional 
	}
	
	public enum SeasonComplex {
		 WINTER(Season.WINTER); //; is mandatory 
		
		private SeasonComplex(Season s) {
			
		}
	}
	
	public static void main(String[] args) {
		Season[] x = Season.values();
	}
}


public enum Season { //only public or package-access
 WINTER, SPRING, SUMMER, FALL; //since this is a simple-enum, ; is OPTIONAL
} //this is so called 'simple-enum' -> only contains a list of values


var s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true


As you can see, enums print the name of the enum when toString() is called. They can
be compared using == because they are like 'static final' constants. In other words, you
can use equals() or == to compare enums, since EACH ENUM IS INITIALIZED ONLY ONCE in
the Java Virtual Machine (JVM).

Calling the values(), name(), and ordinal() Methods

values() ->  array of all of the values: Season[] x = Season.values();
for(var season: Season.values()) {
 System.out.println(season.name() + " " + season.ordinal());
}
WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t compare an int and an enum value directly anyway since an enum is a type, like
a Java class, and not a primitive int.
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE


Season s = Season.valueOf("SUMMER"); // SUMMER 
//***Note that line above is
not creating an enum value, at least not directly. Each enum value is created once when the
enum is first loaded. Once the enum has been loaded, it retrieves the single enum value with
the matching name.

Season t = Season.valueOf("summer"); // IllegalArgumentException


Season summer = Season.SUMMER;
switch(summer) {
 case WINTER: // <- enums in switch statement must be noted as 'WINTER' not as  'Season.WINTER'
	System.out.print("Get out the sled!");
	break;
 case SUMMER:
	System.out.print("Time for the pool!");
	break;
 default:
	System.out.print("Is it summer yet?");
} //DOES COMPILE


Season summer = Season.SUMMER;
var message = switch(summer) {
 case Season.WINTER -> "Get out the sled!"; // DOES NOT COMPILE
 case 0 -> "Time for the pool!"; // DOES NOT COMPILE; pay attention
 default -> "Is it summer yet?";
};

Adding Constructors, Fields, and Methods

Example1:


public class Enums1 {
	
	
	public enum SeasonComplex {
		
		
		WINTER(Season.WINTER), SUMMER(Season.SUMMER), TEST(1), TEST2(""); //; is mandatory 
		//The part 'WINTER(Season.WINTER)' (and others) represent constructor call without a 'new' keyword
		
		//These "fake" constructor calls, must be first lines of the Enum file. Apparently these constructor call are made for JVM for initial initialization and assignment
		
		//The first time we ask for any of the enum values, Java constructs all of the enum values. After that, Java just returns the already constructed enum values.
		
		//if we try to add: ', TEST3(this.x1)' in as one more constructor call we get error: 'Cannot use 'this' in a static context'
		
		private  int x1;
		private  Season s; //if it is 'final' the it must be assigned a value either in a instance block or in a constructor (note: every constructor is considered for 'final' variables assignments on its own, i.e. if we or JVM calls any constructor, each 'final' variable must be assigned) 
		
		//SeasonComplex
		{s = null;} //DOES COMPILE
		
		private static String x = initX();
		{System.out.println("Upper block in SeasonComplex");}
		
		static {
			System.out.println("upper static in SeasonComplex");
		}
		
		private SeasonComplex(Season s) {
			System.out.println("Constructor with Season");
		}
		private SeasonComplex(int x) {
			System.out.println("Constructor with int");	
		}
		
		private SeasonComplex(String x) {
			System.out.println("Constructor with String");
		}
		
		private SeasonComplex(long x) { //we can have 'other' constructors 
			System.out.println("Constructor with long");
		}
		
		private SeasonComplex() {
			System.out.println("Constructor no-args");
		}
		
		//private SeasonComplex(int i) {this(555);} //DOES NOT COMPILE; recursive constructor
		//private SeasonComplex(int x) {} //DOES NOT COMPILE; Duplicate method
		
		public static void s() {}
		
		private static String initX(){
			System.out.println("initX called...");
			return "aa";
		}
		
		{System.out.println("Lower block in SeasonComplex");}
		static {
			System.out.println("Lower static in SeasonComplex");
		}
		
		 public void printExpectedVisitors() {
			System.out.println(x1);
		 }
	}
	
	public enum Season {
		 WINTER, SPRING, SUMMER, FALL; //; is optional if there is nothing in the enum (simple enum). If there is something, like instance block, then ; is mandatory 
		 {System.out.println("@ffff");}
		 
		
	}
	
	public static void main(String[] args) {
		Season[] x = Season.values();
		SeasonComplex[] s = SeasonComplex.values();
		SeasonComplex.SUMMER.s();
//		
//		Season x = SeasonComplex.SUMMER.s; //even though 's' is private in a enum file it is still accessible in this manner
//		int y = SeasonComplex.TEST.x1; // even though 'x1' is private in a enum file it is still accessible in this manner
//		
//		int x1 = SeasonComplex.SUMMER.x1; //even though 'x1' is private in a enum file it is still accessible in this manner
//		Season y1 = SeasonComplex.TEST.s;  //even though 's' is private in a enum file it is still accessible in this manner
		
	}
}

Output:

@ffff
@ffff
@ffff
@ffff
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with Season
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with Season
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with int
Upper block in SeasonComplex
Lower block in SeasonComplex
Constructor with String
initX called...
upper static in SeasonComplex
Lower static in SeasonComplex


***Interestingly, static members are eveluated last...

Example 2:


public enum OnlyOne {
 ONCE(true);
 private OnlyOne(boolean b) {
 System.out.print("constructing,");
 }
}
public class PrintTheOne {
 public static void main(String[] args) {
 System.out.print("begin,");
 OnlyOne firstCall = OnlyOne.ONCE; // Prints constructing,
 OnlyOne secondCall = OnlyOne.ONCE; // Doesn't print anything
 System.out.print("end");
 }
}

**If the OnlyOne enum was used earlier in the program, and therefore initialized sooner,
then the line that declares the firstCall variable would not print anything.


How do we call an enum method? That’s easy, too: we just use the enum value followed by the method call.
Season.SUMMER.printExpectedVisitors();

Example3:

public enum Season {
 WINTER {
 public String getHours() { return "10am-3pm"; }
 },
 SPRING {
 public String getHours() { return "9am-5pm"; }
 },
 SUMMER {
 public String getHours() { return "9am-7pm"; }
 },
 FALL {
 public String getHours() { return "9am-5pm"; }
 };
 public abstract String getHours();
}

Example3a:

public enum Season {
 WINTER {
 public String getHours() { return "10am-3pm"; }
 },
 SUMMER {
 public String getHours() { return "9am-7pm"; }
 },
 SPRING, FALL;
 public String getHours() { return "9am-5pm"; } //We only code the special cases and let the others use the enum-provided implementation
}

Example4:

public interface Weather { int getAverageTemperature(); }
public enum Season implements Weather {
 WINTER, SPRING, SUMMER, FALL;
 public int getAverageTemperature() { return 30; }
}

***This was not an accident. Whether the enum is simple
or complex, the list of values always comes first.



--------------------------------------

Sealing Classes


Sealing allows classes and interfaces to define their permitted subtypes.
In other words, a class or an interface can now define which classes can implement or extend it. It is a useful feature for domain modeling and increasing the security of libraries.


 having restricted subclasses should not limit the accessibility of its superclass.
Thus, the main motivation behind sealed classes is to have the possibility for a superclass to be widely accessible but not widely extensible.

***sealed -> Indicates that a class or interface may only be extended/implemented by named classes or interfaces

***permits -> Used with the sealed keyword to list the classes and interfaces allowed

***non-sealed -> Applied to a class or interface that extends a sealed class, indicating that it can be extended by unspecified classes

Example1:

public class sealed Frog permits GlassFrog {} // DOES NOT COMPILE; 'sealed' must be before 'class' keyword
public final class GlassFrog extends Frog {}

Example2:

public abstract sealed class Wolf permits Timber {} // DOES COMPILE; can be abstract; Sealed classes are commonly declared with the abstract modifier, although this is certainly not required
public final class Timber extends Wolf {}
public final class MyWolf extends Wolf {} // DOES NOT COMPILE; MyWolf is not defined in the 'permits' list of the Wolf class; The type MyWolf extending a sealed class Wolf should be a permitted subtype of Wolf

Example3:

***a sealed class needs to be declared (and compiled) in the same package as its direct subclasses.
//Bear1.java
 package sealed;
 import sealed.test.Kodiak1;
 import sealed.test.Panda1;
 public sealed class Bear1 permits Kodiak1, Panda1 {} //DOES NOT COMPILE: Permitted type Kodiak1 in an unnamed module should be declared in the same package sealed of declaring type Bear1
 																	      Permitted type Panda1 in an unnamed module should be declared in the same package sealed of declaring type Bear1
 //Kodiak1.java
  package sealed.test;
  import sealed.Bear1;
  public final class Kodiak1 extends Bear1 {}  //DOES COMPILE 
  
 //Panda1.java
  package sealed.test;
  import sealed.Bear1;
  public non-sealed class Panda1 extends Bear1 {}  //DOES COMPILE 


Example4:

But what about the subclasses themselves?
They must each extend the sealed class. 

//Penguin.java
package test3;

public sealed class Penguin permits Emperor {} // DOES NOT COMPILE; Permitted class Emperor does not declare test3.Penguin as direct super class

//Emperor.java
package sealed.test3;

public final class Emperor {}

***Specifying the Subclass Modifier
While some types, like interfaces, have a certain number of implicit modifiers, sealed classes
do not. Every class that directly extends a sealed class must specify exactly one of the following three modifiers: final, sealed, or non-sealed. Remember this rule for the exam!



Modifier1: 'final'

public sealed class Antelope permits Gazelle {}
public final class Gazelle extends Antelope {}
public class George extends Gazelle {} // DOES NOT COMPILE


Modifier2: 'sealed'

public sealed class Mammal permits Equine {}
public sealed class Equine extends Mammal permits Zebra {}
public final class Zebra extends Equine {}

The sealed modifier applied to the subclass Equine means the same kind of rules that
we applied to the parent class Mammal must be present. Namely, Equine defines its own list
of permitted subclasses. Notice in this example that Zebra is an indirect subclass of Mammal
but is not named in the Mammal class


Modifier3: 'non-sealed'

The non-sealed modifier is used to open a sealed parent class to potentially unknown subclasses.

public sealed class Wolf permits Timber {}
public non-sealed class Timber extends Wolf {}
public class DummyWolf extends Timber {}

then this is allowed: public class MyFurryWolf extends MyWolf {}

Example5:

// Snake.java -> This is regular way of doing:
public sealed class Snake permits Cobra {}
final class Cobra extends Snake {} 

// Snake.java 
public sealed class Snake { //omits 'permits' keyword
	public static void main(String args[]) {
		System.out.print("D"); //print D
	}
}
final class Cobra extends Snake {} 

If we had two files:

// Snake.java
public sealed class Snake {}
final class Cobra extends Snake {}
If these classes were in separate files, this code would not compile! 
// Snake.java
public sealed class Snake {
 final class Cobra extends Snake {}
}

Example6:

Previous rule also applies to sealed classes with nested subclasses.

// Snake.java
public sealed class Snake {
	public static void main(String args[]) {
	 	System.out.print("D");	 //prints D
	}
 	final class Cobra extends Snake {} //nested subclass; DOES COMPILE
}

However, if we try to use 'permits' in this example:

public sealed class Snake permits Cobra{ // DOES NOT COMPILE; it must be written as public sealed class Snake permits Snake.Cobra{...}
	public static void main(String args[]) {
	 	System.out.print("D");	 
	}
 	final class Cobra extends Snake {} //nested subclass
}
**When all of your subclasses are nested, we strongly recommend omitting the
permits class.

Usage of the permits clause in sealed classes:

Location of direct subclasses 										permits clause

In a different file from the sealed class 						    Required
In the same file as the sealed class 								Permitted, but not required
Nested inside of the sealed class 									Permitted, but not required


Sealing Interfaces


One distinct feature of a sealed interface is that the permits list can apply to a class that
implements the interface or an interface that extends the interface.
// Sealed interface
public sealed interface Swims permits Duck, Swan, Floats {} //with intefaces in 'permits', we can mix class (which impl 'sealed' interface) and other interfaces (which extend 'sealed' interface)

// Classes permitted to implement sealed interface
public final class Duck implements Swims {}
public final class Swan implements Swims {}

// Interface permitted to extend sealed interface
public non-sealed interface Floats extends Swims {}

***
What about the modifier applied to interfaces that extend the sealed interface? Well,
remember that interfaces are implicitly abstract and cannot be marked final. For
this reason, interfaces that extend a sealed interface can only be marked sealed or
non-sealed. They cannot be marked final.

Sealed Class Rules:

Any time you see a sealed class on the exam, pay close attention to the subclass declaration
and modifiers.

■ Sealed classes are declared with the sealed and permits modifiers.
■ Sealed classes must be declared in the same package or named module as their direct subclasses.
■ Direct subclasses of sealed classes must be marked final, sealed, or non-sealed.
■ The permits clause is optional if the sealed class and its direct subclasses are declared within the same file or the subclasses are nested within the sealed class.
■ Interfaces can be sealed to limit the classes that implement them or the interfaces that extend them.
■ Iterfaces that extend a sealed interface can only be marked sealed or non-sealed. They cannot be marked final.