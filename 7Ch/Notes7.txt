
Classes, interfaces and abstract classes

Example1:

public class Interfaces {
	
	interface Fly{ //in every interface, methods are by default 'public abstract'
		void fly(); //same as in abstract methods in abstract classes, must have (param1, param2), no body with {} and must have ; at the end
		//'void fly();' is equivalent to 'public abstract void fly();'
	}
	
	interface Swim{
		void swim();
	}
	
	abstract class Animal{
		abstract CharSequence getType();
//		String getType() { //same method signature in abstract class; DOES NOT COMPILE
//			return null;
//		}
	}
	
	abstract class Bird extends Animal implements Fly{
		//Since it is an abstract class, no need to implement Fly interface, although we could, like so:
		public void fly() { //must be public; if it is not public, and we leave package-access level, we get DOES NOT COMPILE
							//since methods in interfaces have public access by default
			
			//super.getType() //DOES NOT COMPILE; not exists in super-class since it super-class is abstract
			
		} //we could comment this implementation and it would compile
		
		//public abstract Object fly(); //DOES NOT COMPILE; The return type is incompatible with Fly.fly()
		
		//abstract public void fly(); //DOES COMPILE ( as long as we have uncommented implementation of fly() ); but is not necessary thing to do; Cannot have 'abstract public void fly();' and 'public void fly() {...}' at the same time
		//abstract void fly(); //DOES NOT COMPILE; Reduced visibility from interface
		
		//abstract Object getType(); //DOES NOT COMPILE; Incompatible return type from superclass Animal
		
		abstract String getType(); //can have, but it also can be commented; same method as in super-abstract-class 'Animal'. This is some kind of 'override'. Same package access since this method is coming from a superclass not from a interface 
		
		//some other regular abstract method
		abstract boolean test();
		
		
		**Some conclusion on my own: if the compile figures out that METHOD SIGNATURE is matching from either a superclass or a interface, then it starts to apply rules for overriding, package access, return type etc...
		
	}
	
	class Swan extends Bird implements Swim{
		
		public boolean test(){
			return false;
		}
		
		String getType() {
			return null;
		}
		
		//public void fly() {}	//Commented method DOES COMPILE since we gave implementation for interface Fly.fly() in abstract superclass
		
		public void swim() {}	
	}
}



Example2:

public class Interfaces2 {
	
	public abstract interface CanBurrow { //'abstract' is an implicit modifier which compiler inserts into interface declaration
		 public abstract Number getSpeed(int age);
		 public static final int MINIMUM_DEPTH = 2;
	}
	
	public interface Climb {
		Float getSpeed(int age);
	}
	
	public class FieldMouse implements Climb, CanBurrow {
		public Float getSpeed(int age) {
			return 11f;
		} //one method implementation for two interfaces
	}
}


Example3:

public class Interfaces3 {
	public interface Nocturnal {
		 public int hunt();
	}
	public interface CanFly {
		 public void flap();
	}

	public interface HasBigEyes extends Nocturnal, CanFly {
		 public void flap(); //DOES COMPILE; it also compiles if we omit this line and leave empty {}
	}

	public class Owl implements HasBigEyes {
		 public int hunt() { return 5; }
		 public void flap() { System.out.println("Flap!"); }
	}
}

Example4:


public class Interfaces4 {
	public interface HasTail {
		 public int getTailLength();
		}
		public interface HasWhiskers {
		 public int getNumberOfWhiskers();
		}
		abstract class Test{
			abstract void t();
		}
		
		public abstract class HarborSeal extends Test implements HasTail, HasWhiskers {}
		
		public class CommonSeal extends HarborSeal {} // DOES NOT COMPILE
}

**The HarborSeal class compiles because it is abstract and not required to implement
any of the abstract methods it inherits or implements. The concrete CommonSeal class, though, must
override all inherited abstract methods.

Example5:

public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
public class Hyena2 {}
public interface HasFur2 implements Hyena2 {} // DOES NOT COMPILE


Example6:

public class Interfaces5 {
	//Example a:
//	public interface Herbivore { public void eatPlants(); }
//	public interface Omnivore { public void eatPlants(); }
//	
//	public class Bear implements Herbivore, Omnivore {
//
//		public void eatPlants() {
//			System.out.println("Eating plants");
//	 } 
//	}
	
	//Example b:
//	public interface Herbivore2 { public String eatPlants(); }
//	public interface Omnivore2 { public StringBuilder eatPlants(); } 	
//	
//	public class Horse implements Herbivore2, Omnivore2 {
//	
//		public CharSequence eatPlants() { //Question to ask to myself: "Is CharSequence a String??" or "Is CharSequence a StringBuilder??"
//			//Since answer is NO: ----> DOES NOT COMPILE
//			return null;
//	 }
//	}
	
	//Example c:
//	public interface Herbivore3 { public CharSequence eatPlants(); }
//	public interface Omnivore3 { public CharSequence eatPlants(); } 	
//	
//	public class Donkey implements Herbivore3, Omnivore3 {
//	
//		public String eatPlants() { //Question to ask to myself: "Is String a CharSequence??" or "Is StringBuilder a CharSequence??" - Compatible method ---> meaning, a method can be written that properly overrides both inherited
																																							  methods: for example, by using covariant return types that you learned about in Chapter 6
//			//Since answer is YES: ----> DOES COMPILE
//			return null;
//	 }
//	}

	//Example d:
	public interface Herbivore4 { public void eatPlants(); }
	public interface Omnivore4 { public int eatPlants(); }
	public class Tiger implements Herbivore4, Omnivore4 { // DOES NOT COMPILE - 
		//It’s impossible to write a version of Tiger that satisfies both inherited abstract
		//methods. The code does not compile, regardless of what is declared inside the Tiger class.
	}
}

Example7:

public class Interfaces6 {
	public interface Dance {
		 //private int count = 4; // DOES NOT COMPILE
		 //protected void step(); // DOES NOT COMPILE
		 *two compilation erros
		
		private static void test() { } // DOES COMPILE
		
		private  void test2() {}  // DOES COMPILE
		
	}
}


--------------------------------------

default Interface Method

A default method is a method defined in an interface with the default keyword
and includes a method body. It may be optionally overridden by a class implementing the
interface.

Example1:

 interface IsColdBlooded {
	 boolean hasScales();
	 default double getTemperature() {
		 return 10.0;
	 } 
}
public class Snake implements IsColdBlooded {

	 public boolean hasScales() { // Required override
		 return true;
	 }
	 
	 public double getTemperature() { // Optional override
		 return 12;
	 }
	 
	 public static void main(String[] args) {
		Snake s = new Snake();
		System.out.println(s.getTemperature());;
		//IsColdBlooded.getTemperature(); //DOES NOT COMPILE;  they are associated with the instance of the class implementing the interface.
	}
}

Example2:

TODO...Don't know what...

!!!Default Interface Method Definition Rules!!! 

1. A default method may be declared only within an interface.

public class Rule {
	
	public interface HasTail {}
	
	class Test implements HasTail{
		default void test(); //DOES NOT COMPILE
	}
}
	
	
2. A default method must be marked with the default keyword and include a method body.

public class Rule {
	
	public interface HasTail {
		//default void test(); //DOES NOT COMPILE
		default void test() {
			//DOES COMPILE
		}
	}
	class Test implements HasTail{
		
	}
}


3. A default method is implicitly public.

public class Rule {
	
	public interface HasTail {

		public default void test() {} //DOES COMPILE
		default void test2 () {} //DOES COMPILE
	}
}


4. A default method cannot be marked abstract, final, or static.

public class Rule {
	
	public interface HasTail {
		public abstract default void test3 () {} //DOES NOT COMPILE: Cannot be 'abstract' since they must have a body/("deafault")implementation Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public static default void test4 () {} //DOES NOT COMPILE: they are associated with the instance of the class implementing the interface. Illegal combination of modifiers for the interface method test3; only one of abstract, default, or static permitted
		public final default void test3 () {} //DOES NOT COMPILE: they are designed so that they can be overridden in classes implementing the interface, just like abstract methods. 
	}

}


5. A default method may be overridden by a class that implements the interface.

*Example1 in this section, above

6. If a class inherits two or more default methods with the same method signature, then the class must override the method.

Exaplanation for Rule 6:

Inheriting Duplicate default Methods

The last rule for creating a default interface method requires some explanation. For example,
what value would the following code output?
public interface Walk {
 public default int getSpeed() { return 5; }
}
public interface Run {
 public default int getSpeed() { return 10; }
}
public class Cat implements Walk, Run {} // DOES NOT COMPILE
In this example, Cat inherits the two default methods for getSpeed(), so which does
it use? Since Walk and Run are considered siblings in terms of how they are used in the Cat
class, it is not clear whether the code should output 5 or 10. In this case, the compiler throws
up its hands and says, “Too hard, I give up!” and fails.
All is not lost, though. If the class implementing the interfaces overrides the duplicate
default method, the code will compile without issue. By overriding the conflicting method,
the ambiguity about which version of the method to call has been removed. For example, the
following modified implementation of Cat will compile:

public class Cat implements Walk, Run {
 public int getSpeed() { return 1; }
}

--------------------------------------

Calling a Hidden default Method


In the last section, we showed how our Cat class could override a pair of conflicting
default methods, but what if the Cat class wanted to access the version of getSpeed() in
Walk or Run? Is it still accessible?
Yes, but it requires some special syntax.
public class Cat implements Walk, Run {
 public int getSpeed() {
 return 1;
 }
 public int getWalkSpeed() {
 return Walk.super.getSpeed(); //Note that calling Walk.getSpeed() or Walk.this.getSpeed() would not have worked
							   //We use the interface name to indicate which method we want to call, but we
						       //use the super keyword to show that we are following instance inheritance, not class inheritance.
 } }


--------------------------------------

Declaring static Interface Methods

Static Interface Method Definition Rules
1. A static method must be marked with the static keyword and include a method body.
2. A static method without an access modifier is implicitly public.
3. A static method cannot be marked abstract or final.
4. A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.

interface Test1{
	static void m() {} //static methods are not inherited like default
}

interface Test2{
	static void m() {}
}
interface Swim{
	//Rule1
	//public static void print(); //DOES NOT COMPILE; need body implementation
	
	//Rule2
	 static void print() {} //DOES COMPILE; equivalent to: 'public static void print(){}'
	 
	//Rule3
	// static abstract void print2() {} //DOES NOT COMPILE;
	// static final void print3() {} //DOES NOT COMPILE;
}

public class Interfaces7 implements Test1, Test2, Swim{ //can impl both Test1 and Test2 - Java “solved” the multiple inheritance problem of static interface methods by not allowing them to be inherited
	
	public static void main(String[] args) {
		//usage of static interface methods
		
		Swim.print(); //DOES COMPILE
		
		//print();  //DOES NOT COMPILE; even tho the class implements the interface
		
		Interfaces7 obj = new Interfaces7();
		//obj.print(); //DOES NOT COMPILE;
		
	}
}


--------------------------------------

Reusing Code with private Interface Methods

Example1:

public class Interfaces8 {
	
	interface Swim{
		
		default void print() {
			sm(); //DOES COMPILE
			print(); //DOES COMPILE - Stackoverflow/Recursion
			pr();  //DOES COMPILE
			test();  //DOES COMPILE
		}
		
		//Accessing static and non-static interface methods within a static interface method:
		static void sm() {
			//print(); //DOES NOT COMPILE
			Swim.sm(); //DOES COMPILE
			Swim s = null;
			//s.sm();  //DOES NOT COMPILE
			//test(); //DOES NOT COMPILE
			//pr();  //DOES NOT COMPILE
		}
		
		//Accessing static and non-static interface methods within a non-static private interface method:
		private void pr() {
			pr(); //DOES COMPILE
			Swim.sm(); //DOES COMPILE
			print();  //DOES COMPILE
			test();  //DOES COMPILE
			
			Swim sm = null;
			sm.print();  //DOES COMPILE - NPE
			
			Swim sm2 = null;
			sm2.test();   //DOES COMPILE - NPE
			
		}
		
		void test();
	}

}

Example2:

public class Interfaces9 {
	public interface Schedule {
		 default void wakeUp() { checkTime(7); test();}
		 private void haveBreakfast() { checkTime(9); test();}
		 static void workOut() { checkTime(18); }
		 
		 void test1();
		 
		 private void test() {
			 test1();
		 }
		 
		 private static void checkTime(int hour) {
			 if (hour> 17) {
				 System.out.println("You're late!");
			 } else {
				 System.out.println("You have "+(17-hour)+" hours left to make the appointment");
			 } 
			 
			 //test(); //DOES NOT COMPILE
			 workOut(); //DOES COMPILE
		 } 
	}
}

The difference between a non-static private method and a static one is analogous to the difference between an instance and static method declared within a class. In
particular, it’s all about what methods each can be called from.
Private Interface Method Definition Rules
1. A private interface method must be marked with the private modifier and include a method body.
2. A private static interface method may be called by any method within the interface definition.
3. A private interface method may only be called by default and other private nonstatic methods within the interface definition.

Another way to think of it is that a private interface method is only accessible to nonstatic methods defined within the interface. A private static interface method,  
on the other hand, can be accessed by any method in the interface. For both types of private
methods, a class inheriting the interface cannot directly invoke them.
