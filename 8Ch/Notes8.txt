Proper lambda syntax


I Single parameter FunctionalInterfaces with a return type (examples wihich COMPILE nad DO NOT COMPILE):

        @FunctionalInterface
        interface SomeFunctionalInterface{
            int doInt(String s); //s - parameter; //return type 'int'
        }

        //DO COMPILE EXAMPLES
		
        SomeFunctionalInterface sfi0 = stringParam0 -> Math.round(3.4f); //
        //Left side -> No parenthesis; any name for parameter
        //Right side -> No parenthesis; no return statement if it is single lint which does return an int. Must return int


        SomeFunctionalInterface sf01 = (stringParam01) -> Math.round(3.4f);
        //Left side -> Parenthesis; any name for parameter
        //Right side -> No parenthesis; no return statement if it is single lint which does return an int. Must return int


        SomeFunctionalInterface sfi1 = stringParam1 -> {return 5;};
        //Left side -> No parenthesis; any name for parameter
        //Right side -> Braces; required return statement if curly braces are used, not matter how many lines are give. Must return int

        SomeFunctionalInterface sfi2 = stringParam2 -> (int)5.0;  //DOES COMPILE

        SomeFunctionalInterface sfi3 = (String stringParam3) -> 5; //DOES COMPILE
        //Left side -> Parenthesis; required if parameter type is used

        SomeFunctionalInterface sfi4 = (String stringParam4) -> {
            //do something
            //do something
            return 555;
        };
        //Left side -> Parenthesis; required if parameter type is used
        //Right side -> Braces; required return statement if curly braces are used, not matter how many lines are give. Must return int

        SomeFunctionalInterface sfi5 = stringParam5 -> stringParam5.length();
        //Left side -> No parenthesis; any name for parameter
        //Right side -> No return statement if one line is used which DOES return an int;  

        SomeFunctionalInterface sf6 = stringParam6 -> (5); //DOES COMPILE

        //DO NOT COMPILE EXAMPLES
        SomeFunctionalInterface x1 = stringParam1 -> return Math.round(3.4f);
        SomeFunctionalInterface x2 = stringParam2 -> {return Math.round(3.4f)};
        SomeFunctionalInterface x3 = stringParam3 -> {return Math.round(3.4f);}
        SomeFunctionalInterface x4 = stringParam4 -> 123L;
        SomeFunctionalInterface x5 = String stringParam5 -> 5;
        SomeFunctionalInterface x6 = stringParam6, x -> 5;
        SomeFunctionalInterface x7 = (stringParam7, x) -> 5;
        SomeFunctionalInterface x8 = (String stringParam8, int x) -> 5;

II Two-parameters FunctionalInterfaces with a return type (examples wihich COMPILE nad DO NOT COMPILE):


        @FunctionalInterface
        interface MultiParameterInterface{
           Object  doInt(String s, int x);
        }
		
		//DO COMPILE EXAMPLES
		
        MultiParameterInterface mp1 = (x, y) -> new String();
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface mp2 = (String x, int y) -> null;
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters; Type for parameters may be optional
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface mp3 = (x, y) -> { return null;};
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters
        //Right side -> If there are curly braces, return must be present with ; after the return value itself and also after ending curly brace

        MultiParameterInterface mp4 = (x, y) -> {
            //do something
            //do something
            //optionally you can use parameters in body, or effectively final variables from outside of lambda body (more on that later)
            return null;};


        //DO NOT COMPILE EXAMPLES
		
         MultiParameterInterface x1 = (String x, y) -> null;
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters; Type for parameters may be optional, but BOTH parameters must have type
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface x2 =  x, y -> null;
        //Left side -> Must have parenthesis

        MultiParameterInterface x3 =  String x, int y -> null;
        //Left side -> Must have parenthesis

        MultiParameterInterface x4 =  (String x, int y) -> return null;
        //Right side -> must have curly braces if return statement is included

        MultiParameterInterface x5 =  (String x, int y) -> {return null; }
        //Right side -> must have ; after {}

Fun fact lambda:

 interface Pera{
    void perica();
  }

  public static void main(String[] args) {
        Pera pera = () -> {};     //DOES COMPILE
       //Pera pera1 = () -> (); //DOES NOT COMPILE
       //Pera pera2 =  -> (); //DOES NOT COMPILE
       //Pera pera3 = () -> ; //DOES NOT COMPILE
	   //Pera pera4 = () -> {} //DOES NOT COMPILE
	   
	   //var x = () -> System.out.println("aa"); //DOES NOT COMPILE
  }

--------------------------------------

Defining a Functional Interface - 

A functional interface is an interface that contains a single
abstract method. Your friend Sam can help you remember this because it is officially known
as a single abstract method (SAM) rule.

@FunctionalInterface
public interface Sprint {
 public void sprint(int speed);
}

Given our previous Sprint functional interface, which of the following are functional interfaces?

public interface Dash extends Sprint {}

public interface Skip extends Sprint {
 void skip();
}

public interface Sleep {
 private void snore() {}
 default int getZzz() { return 1; }
}

public interface Climb {
 void reach();
 default void fall() {}
 static int getBackUp() { return 100; }
 private static boolean checkHeight() { return true; }
}

Dash - e is a functional interface because it extends the Sprint interface and inherits the single abstract method sprint()

Skip - is not a valid functional interface because it has two abstract methods: the inherited sprint() method and the declared skip() method.

Sleep - is not a valid functional interface. Neither snore() nor getZzz() meets the criteria of a single abstract method. Even though 'default' methods operates simmilar like
	    abstract methods, in that they can be overridden in a class implementing the interface, they are insufficient for satisfying the single abstract method requirement

Climb - e is a functional interface. Despite defining a slew of methods, it contains only one abstract method: reach().		


--------------------------------------

Exception to SAM (single abstract method) rule for determining if it is a valid Functional Interface

■ public String toString()
■ public boolean equals(Object)
■ public int hashCode()

If a functional interface includes an abstract method with the same signature as a public method found in Object, those methods do not count
toward the single abstract method test. The motivation behind this rule is that any class that
implements the interface will inherit from Object, as all classes do, and therefore always
implement these methods.

public interface Soar { //IS NOT a FunctionalInterface
 abstract String toString();
}

public interface Dive { //IS a FunctionalInterface
 String toString();
 public boolean equals(Object o);
 public abstract int hashCode();
 public void dive();
}

public interface Hibernate { //IS NOT a FunctionalInterface
 String toString();
 public boolean equals(Hibernate o);
 public abstract int hashCode();
 public void rest();
}


--------------------------------------

Defining a Functional Interface - The @FunctionalInterface Annotation

The @FunctionalInterface annotation tells the compiler that you intend for the code to
be a functional interface. If the interface does not follow the rules for a functional interface, the compiler will give you an error.

@FunctionalInterface
public interface Dance { // DOES NOT COMPILE
 void move();
 void rest();
}

Java includes @FunctionalInterface on some, but not all, functional interfaces. This
annotation means the authors of the interface promise it will be safe to use in a lambda
in the future. However, just because you don’t see the annotation doesn’t mean it’s not a
functional interface. Remember that having exactly one abstract method is what makes it a
functional interface, not the annotation.
--------------------------------------

Using Method References

You can pretend the compiler turns your method references into lambdas for you.

There are four formats for method references:
■ 1. static methods
■ 2. Instance methods on a particular object
■ 3. Instance methods on a parameter to be determined at runtime
■ 4. Constructors

1. Calling static Methods

public class StaticMethodReferences {

    interface Converter {
        long round(double num);
    }

    interface StringConverter {
        String print(double num, boolean negative);
    }

    static class MyConverterHelperClass{
        public static long zaokruzi(double d){
            return (long)d;
        }

        public static int zaokruzi(float f){
            return (int)f;
        }
    }

    static class MyConverterHelperToStringClassWithTwoParameters{
        public static String print(double d, boolean negative){
            if (negative) System.out.println("I print only positive Doubles");
            return Double.toString(d);
        }

        public static String print(float f, boolean negative){
            if (negative) System.out.println("I print only positive Floats");
            return Float.toString(f);
        }
    }

    public static void main(String[] args) {

        //Case I (single parameter method)

        Converter methodRef1 = MyConverterHelperClass::zaokruzi;
        Converter methodRef2 = Math::round;

        //methodRef1 and methodRef2 are same as if we would write, respectively
        Converter lambda1 = parameter -> MyConverterHelperClass.zaokruzi(parameter);
        Converter lambda2 = parameter -> Math.round(parameter);
		
		//Calling
        methodRef1.round(2.0);
        methodRef2.round(2.3);
        lambda1.round(2.3);
        lambda2.round(22.2);


        //My prevod za (methodRef1 i lambda1):
        /*
            - Metoda 'zaokruzi' koju referenciramo preko klase MyConverterHelperClass, ima istu deklaraciju (tip i redosled paramatara koje ocekuje kao i povratan tip)
              kao i SAM metoda 'round' iz funkcionalnog interfejsa Converter
         */

        //We have referenced a method using method references. Java compiler knows three things:
        /*
            1. Java knows that in a lambda we are referencing a particular method with one parameter.
            2. Java knows to pass that parameter to the method
            3. In case of overloaded method we are referencing, Java infers information from the CONTEXT and uses that information to call appropriate method
                Information from the context which are used by the compiler:
                    -We said that we were declaring a Converter, which has a method taking a double parameter.
                    -Java looks (within MyConverterHelperClass class) for a method that matches that description. If it can’t find it or finds multiple matches, then the compiler will report an error.
            4. My addition: Java know that 'round' and 'zaokruzi' are expecting sam type of parameters in the sam order and are returning same type.
         */


        //Case II (multi parameter method)

        StringConverter methodRefe1 = MyConverterHelperToStringClassWithTwoParameters::print; //it is working same as in Case I
        StringConverter lamb1 = (x, y) -> new String("some random string");

    }
}

--------------------------------------

2. Instance methods on a particular object


class Student{}

public class InstanceMethodsOnParticularObject {

    interface Checker{
        boolean check(Student s, int year);
    }

    class MyHelperChecker{

        public boolean myCheckerImpl(Student person, int order){ //adding static makes 'Checker metRef1 = myHelperChecker::myCheckerImpl' DOES NOT COMPILE //it expects StaticMethodReference
            if (person == null) return false;
            return order > 10;
        }
    }

    public static void main(String[] args) {

        MyHelperChecker myHelperChecker = new InstanceMethodsOnParticularObject().new MyHelperChecker();

        if (true) myHelperChecker = null;

        Checker metRef1 = myHelperChecker::myCheckerImpl; //'myHelperChecker' variable doesn't have to be final or effectively final; NPE is obvious
        Checker lam1 = (student, years) -> false;

        //Checker ref = MyHelperChecker::myCheckerImpl; //DOES NOT COMPILE; it is not static, even tho "signature" are Correct

        /*
            Explanation for 'Checker metRef1 = myHelperChecker::myCheckerImpl;':
            We are using a reference variable whose class contains particular method ('myCheckerImpl') whose "declaration" is same as in Checker's SAM 'check'.
            So we are using Instance Method ('myCheckerImpl') on Particular Object ('myHelperChecker') to use it implementation for 'check' method.
            It is its implementation (implementation of 'myCheckerImpl') which we are assigning to functional interface type 'Checker'.
         */

        //Calling
        metRef1.check(null, -1);
        lam1.check(null, -2);
    }

}

interface StringChecker {
 boolean check();
}
We implement it by checking if the String is empty:
18: var str = "";
19: StringChecker methodRef = str::isEmpty; //We are providing implementation for SAM 'check()' by utilizing instance method 'isEmpty()' from a String class via particular instance object 'str'
20: StringChecker lambda = () -> str.isEmpty(); //the gets to be translated from methodRef
21:
22: System.out.print(methodRef.check()); // true



--------------------------------------

Difference between StaticMethodReferences and InstanceMethodsOnParticularObject is that actually method signatures must be same (parameter types and return type)
but in first we are referencing implementation (method) using Class::method and in second case we are referencing implementation (method) using
variableFromSomeClass::itsInstanceMethod


--------------------------------------

3. Instance methods on a parameter to be determined at runtime


--------------------------------------

TABLE 8.4 Common functional interfaces

Functional interface 						      Return type		 Method name			# of parameters

Supplier<T>                                         T                    get() 				  	0

Consumer<T> 									   void 			   accept(T) 				1 (T)

BiConsumer<T, U> 								   void                accept(T,U)              2 (T, U)

Predicate<T>                                      boolean               test(T)                 1 (T)

BiPredicate<T, U>                                 boolean               test(T,U)               2 (T, U)

Function<T, R>                                      R                   apply(T)                1 (T)

BiFunction<T, U, R>                                 R                   apply(T,U)              2 (T, U)

UnaryOperator<T>                                    T                   apply(T)                1 (T)

BinaryOperator<T>                                   T                   apply(T,T)              2 (T, T)


--------------------------------------