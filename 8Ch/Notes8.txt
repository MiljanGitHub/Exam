Proper lambda syntax


I Single parameter FunctionalInterfaces with a return type (examples wihich COMPILE nad DO NOT COMPILE):

        @FunctionalInterface
        interface SomeFunctionalInterface{
            int doInt(String s); //s - parameter; //return type 'int'
        }

        //DO COMPILE EXAMPLES
		
        SomeFunctionalInterface sfi0 = stringParam0 -> Math.round(3.4f); //
        //Left side -> No parenthesis; any name for parameter
        //Right side -> No parenthesis; no return statement if it is single lint which does return an int. Must return int


        SomeFunctionalInterface sf01 = (stringParam01) -> Math.round(3.4f);
        //Left side -> Parenthesis; any name for parameter
        //Right side -> No parenthesis; no return statement if it is single lint which does return an int. Must return int


        SomeFunctionalInterface sfi1 = stringParam1 -> {return 5;};
        //Left side -> No parenthesis; any name for parameter
        //Right side -> Braces; required return statement if curly braces are used, not matter how many lines are give. Must return int

        SomeFunctionalInterface sfi2 = stringParam2 -> (int)5.0;  //DOES COMPILE

        SomeFunctionalInterface sfi3 = (String stringParam3) -> 5; //DOES COMPILE
        //Left side -> Parenthesis; required if parameter type is used

        SomeFunctionalInterface sfi4 = (String stringParam4) -> {
            //do something
            //do something
            return 555;
        };
        //Left side -> Parenthesis; required if parameter type is used
        //Right side -> Braces; required return statement if curly braces are used, not matter how many lines are give. Must return int

        SomeFunctionalInterface sfi5 = stringParam5 -> stringParam5.length();
        //Left side -> No parenthesis; any name for parameter
        //Right side -> No return statement if one line is used which DOES return an int;  

        SomeFunctionalInterface sf6 = stringParam6 -> (5); //DOES COMPILE
		SomeFunctionalInterface sf7 = (stringParam7) -> (5123); //DOES COMPILE

        //DO NOT COMPILE EXAMPLES
        SomeFunctionalInterface x1 = stringParam1 -> return Math.round(3.4f);
        SomeFunctionalInterface x2 = stringParam2 -> {return Math.round(3.4f)};
        SomeFunctionalInterface x3 = stringParam3 -> {return Math.round(3.4f);}
        SomeFunctionalInterface x4 = stringParam4 -> 123L;
        SomeFunctionalInterface x5 = String stringParam5 -> 5;
        SomeFunctionalInterface x6 = stringParam6, x -> 5;
        SomeFunctionalInterface x7 = (stringParam7, x) -> 5;
        SomeFunctionalInterface x8 = (String stringParam8, int x) -> 5;

II Two-parameters FunctionalInterfaces with a return type (examples wihich COMPILE nad DO NOT COMPILE):


        @FunctionalInterface
        interface MultiParameterInterface{
           Object  doInt(String s, int x);
        }
		
		//DO COMPILE EXAMPLES
		
        MultiParameterInterface mp1 = (x, y) -> new String();
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface mp2 = (String x, int y) -> null;
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters; Type for parameters may be optional
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface mp3 = (x, y) -> { return null;};
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters
        //Right side -> If there are curly braces, return must be present with ; after the return value itself and also after ending curly brace

        MultiParameterInterface mp4 = (x, y) -> {
            //do something
            //do something
            //optionally you can use parameters in body, or effectively final variables from outside of lambda body (more on that later)
            return null;};


        //DO NOT COMPILE EXAMPLES
		
         MultiParameterInterface x1 = (String x, y) -> null;
        //Left side -> Must have parenthesis when there are two or more parameters present; any name for parameters; Type for parameters may be optional, but BOTH parameters must have type
        //Right side -> No parenthesis; no return statement if it is single lint which does return a covariant of return value

        MultiParameterInterface x2 =  x, y -> null;
        //Left side -> Must have parenthesis

        MultiParameterInterface x3 =  String x, int y -> null;
        //Left side -> Must have parenthesis

        MultiParameterInterface x4 =  (String x, int y) -> return null;
        //Right side -> must have curly braces if return statement is included

        MultiParameterInterface x5 =  (String x, int y) -> {return null; }
        //Right side -> must have ; after {}

Fun fact lambda:

 interface Pera{
    void perica();
  }

  public static void main(String[] args) {
        Pera pera = () -> {};     //DOES COMPILE
       //Pera pera1 = () -> (); //DOES NOT COMPILE
       //Pera pera2 =  -> (); //DOES NOT COMPILE
       //Pera pera3 = () -> ; //DOES NOT COMPILE
	   //Pera pera4 = () -> {} //DOES NOT COMPILE
	   
	   //var x = () -> System.out.println("aa"); //DOES NOT COMPILE
  }

--------------------------------------

Defining a Functional Interface - 

A functional interface is an interface that contains a single
abstract method. Your friend Sam can help you remember this because it is officially known
as a single abstract method (SAM) rule.

@FunctionalInterface
public interface Sprint {
 public void sprint(int speed);
}

Given our previous Sprint functional interface, which of the following are functional interfaces?

public interface Dash extends Sprint {}

public interface Skip extends Sprint {
 void skip();
}

public interface Sleep {
 private void snore() {}
 default int getZzz() { return 1; }
}

public interface Climb {
 void reach();
 default void fall() {}
 static int getBackUp() { return 100; }
 private static boolean checkHeight() { return true; }
}

Dash - e is a functional interface because it extends the Sprint interface and inherits the single abstract method sprint()

Skip - is not a valid functional interface because it has two abstract methods: the inherited sprint() method and the declared skip() method.

Sleep - is not a valid functional interface. Neither snore() nor getZzz() meets the criteria of a single abstract method. Even though 'default' methods operates simmilar like
	    abstract methods, in that they can be overridden in a class implementing the interface, they are insufficient for satisfying the single abstract method requirement

Climb - e is a functional interface. Despite defining a slew of methods, it contains only one abstract method: reach().		


--------------------------------------

Exception to SAM (single abstract method) rule for determining if it is a valid Functional Interface

■ public String toString()
■ public boolean equals(Object)
■ public int hashCode()

If a functional interface includes an abstract method with the same signature as a public method found in Object, those methods do not count
toward the single abstract method test. The motivation behind this rule is that any class that
implements the interface will inherit from Object, as all classes do, and therefore always
implement these methods.

public interface Soar { //IS NOT a FunctionalInterface
 abstract String toString();
}

public interface Dive { //IS a FunctionalInterface
 String toString();
 public boolean equals(Object o);
 public abstract int hashCode();
 public void dive();
}

public interface Hibernate { //IS NOT a FunctionalInterface
 String toString();
 public boolean equals(Hibernate o);
 public abstract int hashCode();
 public void rest();
}


--------------------------------------

Defining a Functional Interface - The @FunctionalInterface Annotation

The @FunctionalInterface annotation tells the compiler that you intend for the code to
be a functional interface. If the interface does not follow the rules for a functional interface, the compiler will give you an error.

@FunctionalInterface
public interface Dance { // DOES NOT COMPILE
 void move();
 void rest();
}

Java includes @FunctionalInterface on some, but not all, functional interfaces. This
annotation means the authors of the interface promise it will be safe to use in a lambda
in the future. However, just because you don’t see the annotation doesn’t mean it’s not a
functional interface. Remember that having exactly one abstract method is what makes it a
functional interface, not the annotation.
--------------------------------------

Using Method References

You can pretend the compiler turns your method references into lambdas for you.

There are four formats for method references:
■ 1. static methods
■ 2. Instance methods on a particular object
■ 3. Instance methods on a parameter to be determined at runtime
■ 4. Constructors

1. Calling static Methods

public class StaticMethodReferences {

    interface Converter {
        long round(double num);
    }

    interface StringConverter {
        String print(double num, boolean negative);
    }

    static class MyConverterHelperClass{
        public static long zaokruzi(double d){
            return (long)d;
        }

        public static int zaokruzi(float f){
            return (int)f;
        }
    }

    static class MyConverterHelperToStringClassWithTwoParameters{
        public static String print(double d, boolean negative){
            if (negative) System.out.println("I print only positive Doubles");
            return Double.toString(d);
        }

        public static String print(float f, boolean negative){
            if (negative) System.out.println("I print only positive Floats");
            return Float.toString(f);
        }
    }

    public static void main(String[] args) {

        //Case I (single parameter method)

        Converter methodRef1 = MyConverterHelperClass::zaokruzi;
        Converter methodRef2 = Math::round;

        //methodRef1 and methodRef2 are same as if we would write, respectively
        Converter lambda1 = parameter -> MyConverterHelperClass.zaokruzi(parameter);
        Converter lambda2 = parameter -> Math.round(parameter);
		
		//Calling
        methodRef1.round(2.0);
        methodRef2.round(2.3);
        lambda1.round(2.3);
        lambda2.round(22.2);


        //My prevod za (methodRef1 i lambda1):
        /*
            - Metoda 'zaokruzi' koju referenciramo preko klase MyConverterHelperClass, ima istu deklaraciju (tip i redosled paramatara koje ocekuje kao i povratan tip)
              kao i SAM metoda 'round' iz funkcionalnog interfejsa Converter
         */

        //We have referenced a method using method references. Java compiler knows three things:
        /*
            1. Java knows that in a lambda we are referencing a particular method with one parameter.
            2. Java knows to pass that parameter to the method
            3. In case of overloaded method we are referencing, Java infers information from the CONTEXT and uses that information to call appropriate method
                Information from the context which are used by the compiler:
                    -We said that we were declaring a Converter, which has a method taking a double parameter.
                    -Java looks (within MyConverterHelperClass class) for a method that matches that description. If it can’t find it or finds multiple matches, then the compiler will report an error.
            4. My addition: Java know that 'round' and 'zaokruzi' are expecting sam type of parameters in the sam order and are returning same type.
         */


        //Case II (multi parameter method)

        StringConverter methodRefe1 = MyConverterHelperToStringClassWithTwoParameters::print; //it is working same as in Case I
        StringConverter lamb1 = (x, y) -> new String("some random string");

    }
}

--------------------------------------

2. Instance methods on a particular object


class Student{}

public class InstanceMethodsOnParticularObject {

    interface Checker{
        boolean check(Student s, int year);
    }

    class MyHelperChecker{

        public boolean myCheckerImpl(Student person, int order){ //adding static makes 'Checker metRef1 = myHelperChecker::myCheckerImpl' DOES NOT COMPILE //it expects StaticMethodReference
            if (person == null) return false;
            return order > 10;
        }
    }

    public static void main(String[] args) {

        MyHelperChecker myHelperChecker = new InstanceMethodsOnParticularObject().new MyHelperChecker();

        if (true) myHelperChecker = null;

        Checker metRef1 = myHelperChecker::myCheckerImpl; //'myHelperChecker' variable doesn't have to be final or effectively final; NPE is obvious
        Checker lam1 = (student, years) -> false;

        //Checker ref = MyHelperChecker::myCheckerImpl; //DOES NOT COMPILE; it is not static, even tho "signature" are Correct

        /*
            Explanation for 'Checker metRef1 = myHelperChecker::myCheckerImpl;':
            We are using a reference variable whose class contains particular method ('myCheckerImpl') whose "declaration" is same as in Checker's SAM 'check'.
            So we are using Instance Method ('myCheckerImpl') on Particular Object ('myHelperChecker') to use it implementation for 'check' method.
            It is its implementation (implementation of 'myCheckerImpl') which we are assigning to functional interface type 'Checker'.
         */

        //Calling
        metRef1.check(null, -1);
        lam1.check(null, -2);
    }

}

Another example:

interface StringChecker {
 boolean check();
}
We implement it by checking if the String is empty:
18: var str = "";
19: StringChecker methodRef = str::isEmpty; //We are providing implementation for SAM 'check()' by utilizing instance method 'isEmpty()' from a String class via particular instance object 'str'
20: StringChecker lambda = () -> str.isEmpty(); //the gets to be translated from methodRef
21:
22: System.out.print(methodRef.check()); // true



--------------------------------------

Difference between StaticMethodReferences and InstanceMethodsOnParticularObject is that actually method signatures must be same (parameter types and return type)
but in first we are referencing implementation (method) using Class::method and in second case we are referencing implementation (method) using
variableFromSomeClass::itsInstanceMethod


--------------------------------------

3. Instance methods on a parameter to be determined at runtime

public class InstanceMethodsOnParameter {
   interface Checker{
        boolean check(MyPersonChecker p);
    }
     class MyPersonChecker {
        public boolean myCheckerImpl(){
            //TODO some implementation
            return false;
        }

         public boolean myCheckerImpl(int x){
             //TODO some implementation
             return true;
         }
    }

    interface StringParameterChecker {
        boolean check(String text);
    }

    public static void main(String ...arg) {

        Checker checker = MyPersonChecker::myCheckerImpl;
        Checker ch = (myCheckerImpl) -> myCheckerImpl.myCheckerImpl();

        //The expression 'Checker checker = MyPersonChecker::myCheckerImpl;' gets translated to 'Checker ch = (myCheckerImpl) -> myCheckerImpl.myCheckerImpl();'

        /*
            Explanation:

            We are referencing a method 'myCheckerImpl' from MyPersonChecker class but this method is not static. Instead,
            Java sees that 'myCheckerImpl' takes no arguments and returns boolean. That is almoooost what is the signature of 'Checker'
            functional interface, namely its SAM.  ****Java uses the parameter supplied at runtime, when calling SAM, as the instance on
            which the method is called.

            Actually, type parameter in SAM and type in method reference and parameter supplied at runtime must be of the same type.
            and parameter passed will be the instance on which the method is called!!!!

         */

        //Calling
        checker.check(new InstanceMethodsOnParameter().new MyPersonChecker());

        StringParameterChecker methodRef = String::isEmpty; // StringParameterChecker lambda = s -> s.isEmpty();


        //Multi parameter example



        interface CheckerTwoParameter{
            boolean check(MyPersonChecker p, int x);
        }

        CheckerTwoParameter checker2 = MyPersonChecker::myCheckerImpl;
		//Wehen looking at the line above I have to make sure that:
		1. In MyPersonChecker there is a method which takse a single int as parameter and returns boolean.
			Why so? Because even tho signature of SAM is   'boolean check(MyPersonChecker p, int x);' the first argument, when calling SAM must be supplied at runtime and it has got to be of type MyPersonChecker,
			that will be the instance on which will the appropriate method be called, in this case a method with single int parameter as show in: '-> myCheckerImpl.myCheckerImpl(x);'
     
		2. 'MyPersonChecker::myCheckerImpl;' look like a static method, but it is really a method reference declaring that the instance of the object will be specified later.
		
		CheckerTwoParameter ch2 = (myCheckerImplFirstParam, x) -> myCheckerImpl.myCheckerImpl(x); //'myCheckerImplFirstParam' will always be the instance of the object for instance methods.!!!!!



        //Calling
        checker2.check(new InstanceMethodsOnParameter().new MyPersonChecker(), 2);
        ch2.check(new InstanceMethodsOnParameter().new MyPersonChecker(), 2222);
		
		Since the functional interface takes two parameters, Java has to figure out what they
		represent. The first one will always be the instance of the object for instance methods. Any
		others are to be method parameters.
		
		

    }
}

Example which DOES NOT COMPILE:

public static void main(String[] args) {
        interface StringConcater { 
            String concatMe(String valueToConcat);
        }
        StringConcater stringAppender = String::concat; //Correct example of calling 'concate(String x)' from String class: 'var x = "asdasd".concat("asd");'
        
		The proper question I need to ask myself is:
		
		Is there a 'concat' method in Strnig class which takse no parameters?? I have to realize that in SAM the 'String valueToConcat' will be the instance on which 'concat' from 'String::concat'
		will be called upon. So when method reference 'String::concat' gets translated to real and proper lambda, I have to ask myself is this regular:
		
		StringConcater stringAppenderTranslatedToLambda = valueToConcat -> valueToConcat.concat(); ??? DOES NOT COMPILE
		
		Instead the FunctionalInterface should be defined as:
		
		interface StringConcater { 
            String concatMe(String instanceToCallConcatMethodOn, String valueToConcat);
        }
		Then we can write: StringConcater stringAppender2 = String::concat
        stringAppender2.concatMe(null, null);
		
		OR
		
		If we decide to stay with original SAM signature, the we can write:
		
		1.
		StringConcater creator4 = String::new; //constructor method reference
		
		2.
		var x1 = "asd";
		StringConcater ref = x1::concat;
		
       
        
    }


--------------------------------------

4. Constructors

class Employee{
    public int age;
    public Employee() {}
    public Employee(int age) {
        this.age = age;
    }
}
public class ConstructorsMethodReferences {
    
    interface EmployeeCreator{
        Employee create();
    }

    interface EmployeeCreatorWithParams{
        Employee create(int x);
    }

    public static void main(String[] args) {
        EmployeeCreator ec = Employee::new;
        final Employee employee = ec.create();
        
        EmployeeCreatorWithParams ecp = Employee::new;
        final Employee employee1 = ecp.create(2);
        
    }
}


--------------------------------------

        /*  Subtle differences on how to distinguish between InstanceMethodsOnParameter(1.) method references and Constructor(2.) method references:

            (1.)

            interface Checker{
                    boolean check(MyPersonChecker p);
            }


             Checker checker = MyPersonChecker::myCheckerImpl;
             Checker ch = (myCheckerImpl) -> myCheckerImpl.myCheckerImpl(); //This "translating" part is important
			 
             //Here you need to make sure that instance, actually, its class, must provide a no arg ins method, since first
             parameter is "spent" as an instance on which method is called


             (2.)

              interface StringCopier {
                String copy(String value);
              }

              StringCopier methodRef = String::new;
              StringCopier lambda = x -> new String(x); //This "translating" part is important
              
              With constructor method references, there is no instance on which anything is called in lambda,
              since we are talking about constructors. Input parameters from left side of an arrow can only be used as
              constructor arguments, if that overloaded constructor do exist, that means that given constructor method reference DOES COMPILE


         */
--------------------------------------


TABLE 8.3 Method references. ********

Type 										             Before colon 				    After colon 					Example                            						Example SAM

static methods 								              Class name 			        Method name 				  Math::round                    							long convert(double d)

Instance methods on a particular object             Instance variable name              Method name                  str::startsWith                 					boolean beginningCheck(String prefix);

Instance methods on a parameter                         Class name                      Method name					 String::isEmpty / String::startsWith;             boolean check(String text); / boolean check(String text, String prefix);

Constructor 											Class name 						   new 						   String::new                                           String create(); / String copy(String value);



--------------------------------------

TABLE 8.4 Common functional interfaces

Functional interface 						      Return type		 Method name			# of parameters

Supplier<T>                                         T                    get() 				  	0

Consumer<T> 									   void 			   accept(T) 				1 (T)

BiConsumer<T, U> 								   void                accept(T,U)              2 (T, U)

Predicate<T>                                      boolean               test(T)                 1 (T)

BiPredicate<T, U>                                 boolean               test(T,U)               2 (T, U)

Function<T, R>                                      R                   apply(T)                1 (T)

BiFunction<T, U, R>                                 R                   apply(T,U)              2 (T, U)

UnaryOperator<T>                                    T                   apply(T)                1 (T)

BinaryOperator<T>                                   T                   apply(T,T)              2 (T, T)


import java.util.function.*;

public class BuiltInFunctionalInterfaces {

    public static void print(Object ... args){
        System.out.println("print args...");
    }

    public static void main(String[] args) {

        BuiltInFunctionalInterfaces bifi = new BuiltInFunctionalInterfaces();

        bifi.Supplier();
        bifi.Consumer();
        bifi.BiConsumer();
        bifi.Predicate();
        bifi.BiPredicate();
        bifi.Function();
		bifi.BiFunction();
    }
    public void Supplier(){
        //SAM
        /*
        @FunctionalInterface
        public interface Supplier<T> {
            T get();
         }
         */

        //Example 1.
        Supplier<String> supplier = String::new; //() -> new String(); it matches with SAM
        supplier.get();
    }

    public void Consumer(){
        //SAM
        /*
                @FunctionalInterface
                public interface Consumer<T> {
                    void accept(T t);
                 }
         */

        //Example 1.
        Consumer<String> consumer = System.out::println; //x -> System.out.println(x);
        consumer.accept("aaa");
    }

    public void BiConsumer(){
        /*
        @FunctionalInterface
        public interface BiConsumer<T, U> {
            void accept(T t, U u);
         }
         */

        BiConsumer<String, Integer> consumer = BuiltInFunctionalInterfaces::print;
        consumer.accept("a", 12);

        class Helper{

            public void test(int x){
                System.out.println("do smtg");
            }
        }
        BiConsumer<Helper, Integer> consumer2 = Helper::test;
        consumer2.accept(new Helper(), 2);


    }

    public void Predicate(){
        //SAM
        /*
        @FunctionalInterface
        public interface Predicate<T> {
            boolean test(T t);
        }
         */

        //Predicate<String> predicate1 = String::startsWith;  //DOES NOT COMPILE
        //Predicate<String> predicate = x -> x.startsWith();  //When trying to do 'Instance method on parameters' mechanism, we get DOES NOT COMPILE
        //The 'x -> x.startsWith();' is important since there is no method in String class "x.startsWith();" then the method references DOES NOT COMPILE
        //and also there is no static method startsWith() in String class
        //However if we had this functional interface:

       /*
        @FunctionalInterface
        public interface MyPredicate<T, X> {
            boolean test(T t, X x);
        }
        class HelperDemo{
            public boolean someM(int x){
                return false;
            }
         }
         MyPredicate<HelperDemo, Integer> myPredicate = HelperDemo::someM; //DOES COMPILE
         myPredicate.test(new Demo().new HelperDemo(), 9);
         //translation:
          MyPredicate<HelperDemo, Integer> translated = (helperDemo, parameter) -> helperDemo.someM(parameter);  //DOES COMPILE
         */


        var x = "abc";
        //Predicate predicate2 = x::startsWith; ////DOES NOT COMPILE; Reference to 'startsWith' is ambiguous, both 'startsWith(String, int)' and 'startsWith(String)' match
        //Predicate predicate = x -> x.startsWith(whateverIsPassedDuringRuntime);  //DOES NOT COMPILE

        Predicate<String> predicate3 = x::startsWith;  //DOES COMPILE
        //Translating: Predicate<String> predicate3 = (x, param1) -> x.startsWith(param1) //DOES COMPILE; Java knows in the above line exactly which method we are referencing
        predicate3.test("a");
    }

    public void BiPredicate(){
        /*
            @FunctionalInterface
            public interface BiPredicate<T t, U u>{
                boolean test(T t, U u);
            }
         */

        BiPredicate<String, String> predicate = String::startsWith;
        //What happens when we attempt to translate:
        //BiPredicate<String, String> predicate = (instanceForMethodToBeCalledOn, param) -> instanceForMethodToBeCalledOn.startsWith(param); //DOES COMPILE so does and method reference
        predicate.test("abc", "a0");

        var x = "abc";
        BiPredicate<String, Integer> predicate2 = x::startsWith;
        //What happens when we attempt to translate:
        //BiPredicate<String, String> predicate22 = (stringParamFromRunTime, intParamFromRuntime) -> x.startsWith(stringParamFromRunTime, IntParamFromRuntime);
        //x - is the instance which we used in method reference
        System.out.println( predicate2.test("a", 0));

        var z = "abc";
        BiPredicate<String, String> predicate22 = z::startsWith;
        //What happens when we attempt to translate:
        //BiPredicate<String, String> predicate22 = (stringParamFromRunTime1, stringParamFromRunTime1) -> z.startsWith(stringParamFromRunTime, stringParamFromRunTime1);
        //The above line DOES NOT COMPILE since there is not startsWith(String s, String s1) in String class
        //z - is the instance which we used in method reference
        System.out.println( predicate22.test("a", "A"));

        var y = "aaa";
        //BiPredicate<String, String> predicate3 = y::startsWith; //DOES NOT COMPILE
        //What happens when we attempt to translate:
        //It can be all this:
        //BiPredicate<String, String> predicate3 = (stringParam1, stringParam2) -> y.startsWith(stringParam1);
        //BiPredicate<String, String> predicate3 = (stringParam1, stringParam2) -> y.startsWith(stringParam2);
        //BiPredicate<String, String> predicate3 = (stringParam1, stringParam2) -> y.startsWith(stringParam1,anInt?);
        //BiPredicate<String, String> predicate3 = (stringParam1, stringParam2) -> y.startsWith(stringParam2,anInt?);


        //BiPredicate<String, Integer> predicate4 = String::startsWith;  //DOES NOT COMPILE,
        //What happens when we attempt to translate:
        // (stringParamFromRuntime, intParam) -> stringParamFromRuntime.startsWith(intParam); //DOES NOT COMPILE, since there is not startsWith(int intParam); in String class




    }
	
    public void Function(){
        /*
        @FunctionalInterface
        public interface Function<T, R> {
             R apply(T t);
        }
        */

        ArrayList<Object> s = new ArrayList<>();
        Function<List, Boolean> ex1 = s::add; //DOES COMPILE
        //Translated to: Function<List, Boolean> ex1 = list -> s.add(list);

        Function<String, Boolean> ex2 = String::isEmpty;
        //Translated to: Function<String, Boolean> ex2 = stringParam -> stringParam.isEmpty()
        ex2.apply("asb");


        //Function<String, String> ex3 = String::concat; // DOES NOT COMPILE
        //Translated to: Function<String, Boolean> ex3 = stringParam -> stringParam.concat(): DOES NOT COMPILE
        //ex3.apply("asb");

        var x = "asd";
        Function<String, String> ex4 = x::concat; // DOES COMPILE
        //Translated to: Function<String, Boolean> ex4 = stringParamFromRuntime -> x.concat(stringParamFromRuntime): DOES COMPILE
        ex4.apply("asb");

        Function<Integer, String> ex5 = String::valueOf;
        //Translated to: Function<Integer, String> ex4 = intParamFromRuntime -> String.valueOf(1);
        ex5.apply(1);
		
	}
}


--------------------------------------