Collections
                 __________         _________
                /          Collection        \
               /               |              \
              /                |               \
             /                 |                \
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
            List             Queue              Set                                     Map
            /   \              |                /\                                      /\
           /     \             |               /  \                                    /  \
          /       \            |              /    \                                  /    \
       ArrayList   \         Deque         HashSet TreeSet                       HashMap  TreeMap
                    \         /
                     \       /
                    LinkedList

--------------------------------------

Diamond operator


List<Integer> list = new ArrayList<>(); //DOES COMPILE
Map<Long,List<Integer>> mapOfLists = new HashMap<>(); //DOES COMPILE

List<> list = new ArrayList<Integer>(); // DOES NOT COMPILE
class InvalidUse {
 void use(List<> data) {} // DOES NOT COMPILE
}

--------------------------------------

Methods available in Collection interface 

- public boolean add(E element)
- public boolean remove(Object object) //Be careful this is overloaded in List, Queue...
- public boolean isEmpty()
- public int size()
- public void clear() 
- public boolean contains(Object object)
- public boolean removeIf(Predicate<? super E> filter)
- public void forEach(Consumer<? super T> action)
- public boolean equals(Object object)

--------------------------------------

The List Interface

- ordered
- allows duplicates
- index based

Comparing ArrayList and LinkedList

ArrayList:

Good at: getting objects / accessing / reading(in constant time) (i.e. Good at READING)
Bad at: adding and removing (i.e. Bad at WRITING)

LinkedList
* additional methods to facilitate adding or removing from the beginning and/or end of the list

Good at: adding and removing (i.e. Bad at WRITING
Bad at:  getting objects / accessing / reading / *dealing with an arbitrary index takes linear time

--------------------------------------

Factory methods

Factory methods to create a List: Arrays.asList(varargs); | List.of(varargs); | List.copyOf(collection);

!!! Arrays.asList(varargs); !!! ---> So called "List view";

"List view" -> - If SIZE is changed either to array (although this is not possible) or to the list (this is possible) then UnsupportedOperationException is thrown!!!
			   - Gives immutable list in terms of size;
			   - *** Since it is so called "List view", we can modify and replace elements in an array or in a list, those changes will automatically be reflected on the other collection. ***

Examples:
	- calling: 'public boolean add(E element)' from Collection -> UnsupportedOperationException
	- calling: 'public boolean remove(Object object)' from Collection -> UnsupportedOperationException
    - calling: 'public E set(int index, E e) [Replaces element at index and returns original. May throw IndexOutOfBoundsException if index is invalid.]' from List -> UnsupportedOperationException

Examples:
		Replacing using set():
		
	    String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        String oldValueAtIndex1Unused = stringList.set(1, null); //replacing here
        System.out.println(Arrays.toString(arr1)); //[a, null]
		
		Modifyig via array:
		
		String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        arr1[0] = "c  //modifying here
        System.out.println(stringList);// [c, b]


!!! List.of(varargs); !!!		
		
List.of(varargs/array); ---> returns FULL IMMUTABLE LIST
						- no adding of elements -> UnsupportedOperationException
						- no removing -> UnsupportedOperationException
						- no replacing (i.e. using set(int, E e) from List); -> UnsupportedOperationException

Examples:
	    Person p1 = new Person(1); Person p2 = new Person(2);
        final List<Person> of = List.of(p1, p2); // The 'of' list contains identical copies of references 'p1' and 'p2'; i.e. References from 'of' and ('p1' and 'p2') are pointing to same objects, respectivly
        System.out.println(p2 == of.get(1)); //true
        of.get(1).id = 22;
        System.out.println(p2); //Person{id=22}
Examples:
		List.of(); //DOES COMPILE
		List.of(1, null); //Exception

!!! List.copyOf(collection); !!!			

Examples:
        final List<Person> copyOf = List.copyOf(personList);
        System.out.println(personList.get(0) == copyOf.get(0)); //true

		personList.remove(p1);
        System.out.println(personList.size()); //1
        System.out.println(copyOf.size()); //2

Method Description 			Can add elements?		Can delete elements?		Can replace elements?

Arrays.asList(varargs/array)    NO							NO							YES

List.of(varargs);				NO 						 	NO							NO

List.copyOf(collection);  		NO 						 	NO							NO

**At this point it would be good to repeat following methods: list.toArray(); list.toArray(someOtherArr); **
--------------------------------------

Creating a List with a Constructor

var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10); //ArrayList has this constructor not LinkedList
var linked2 = new LinkedList<Integer>(100); //DOES NOT COMPILE
--------------------------------------

Using var with ArrayList

var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE; The type of var is ArrayList<Object>

--------------------------------------

Working with List Methods

Beside methods in Collection, here are methods from List interface:

 - public void add(int index, E element) //its not like add(E e) from Collection; this one is void and from Collection is boolean return type
		
		Example1:
		Person p1 = new Person(1); Person p2 = new Person(2);
        List<Person> personList =  new ArrayList<>();
        personList.add(p1); personList.add(p2);
        personList.add(3, new Person(3)); //IndexOutOfBoundsException: Index: 3, Size: 2
        System.out.println(personList);
		
		Example2:
		
		String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        String removedEl = list.remove(1); //list: [a, c]
        String oldReplacedElement = list.set(1, d); //removedEl: c; list: [a, d]
        if (list.add(e)) System.out.println(list); //list: [a, d, e]

		Example3:
        String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        System.out.println(list); //[a, b, c]
        list.add(2, d); //shifts
        System.out.println(list); // [a, b, d, c]
        list.add(3, e);
        System.out.println(list); //[a, b, d, e, c]
	
 - public E get(int index) //Explained above
 - public E remove(int index) //Explained above
 - public E set(int index, E e)  // Explained above: Think of it as 'set' as doing 'replacing'
 
 - public default void replaceAll(UnaryOperator<E> op)
	    String x = "aaf";
        list.replaceAll(String::new); //DOES COMPILE
        list.replaceAll(x::concat); //DOES COMPILE
        list.replaceAll(String::concat); //DOES NOT COMPILE
        list.replaceAll(el -> el.replace("a", "b"));
 
 - public default void sort(Comparator<? super E> c)
	
	//TODO
 
--------------------------------------

Set Methods 

Set<Character> letters = Set.of('z', 'o', 'o'); //Set.of(varargs/array); IMMUTABLE
Set<Character> copy = Set.copyOf(letters); //Set.copyOf(Collection<? extends E> coll); IMMUTABLE

3: Set<Integer> set = new HashSet<>();
4: boolean b1 = set.add(66); // true
5: boolean b2 = set.add(10); // true
6: boolean b3 = set.add(66); // false
7: boolean b4 = set.add(8); // true
8: set.forEach(System.out::println);
This code prints three lines:
66
8
10

--------------------------------------

Queue and Deque Interfaces

	 Queue (FIFO)
	  /|\
	   |
	   |
     Deque (FIFO) //*it may use LIFO methods pop()/push(E e)
	  /|\
	   |
	   |	    
   LinkedList + (it should be obvious that LinkedList implements List)
   
--------------------------------------
   
Queue<String> queue = new LinkedList<>();//DOES COMPILE
Deque<String> deque =  new LinkedList<>(); //DOES COMPILE
LinkedList<String> linkedList =  new LinkedList<>(); //DOES COMPILE
List<String> list = new LinkedList<>();    //DOES COMPILE

--------------------------------------
Queue Methods

 - public boolean add(E e) //Adding; From Collection

	Example1:
	
	Queue<String> queue = new LinkedList<>();
	queue.add("a");  queue.add("b");  //it adds elements to the end
	System.out.println(queue); [a,b]
	queue.add(null); //DOES NOT THROW EXCEPTION
	
 - public boolean offer(E e) //Adding; From Queue

	Example1:

    queue.add("a");  queue.add("b");  queue.add("c");
    queue.offer("a");
    System.out.println(queue);  // [a, b, c, a]

**add(E e) and offer(E e) are very simmilar in whihc that both are adding elements to the back of the list.	

 - public E remove() //Removing; It MAY throw Exception
 
Note: there is a 'public boolean remove(Object object)' from Collections which returns 'boolean' and remove() from Queue returns which returns first inserted element from Queue removes it
	  With remove() from Queue, we got no parameters to pass to the method, which means that it returns removed element, and in accordance with FIFO, it will return "first out", that is, first inserted element
	  
	  Example1:
	  
	    queue.add("a");  queue.add("b");  queue.add("c");
        boolean isRemovedElementByUsingCollectionRemoveMethod = queue.remove("a"); //true
        String removedElementByUsingDequeRemoveMethod = queue.remove(); 
        System.out.println(removedElementByUsingDequeRemoveMethod); //b
        System.out.println(queue); //[c]
	 
	  Example2:
	  
	  Queue<String> queue = new LinkedList<>();
	  String removedElementByUsingDequeRemoveMethod = queue.remove(); // !!! Throws exception if Queue is empty; 
																	 //It should be obvious that remove(Object o) from Collection returns boolean, 
																	//so no Exception will be throw if element we are trying to remove is not present
		
		
 - public E poll() //Removing; It DOES NOT throw Exception
		
	  Example1:
	  
        Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String poll = queue.poll();
        System.out.println(poll); //a
        System.out.println(queue); //[b, c]	  

	  Example2:		
		
		Queue<String> queue = new LinkedList<>();
        final String poll = queue.poll(); // null
		
	
 - public E element()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String element = queue.element();
        System.out.println(element); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String element = queue.element(); //Throws Exception

 - public E peek()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String peek = queue.peek();
        System.out.println(peek); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String peek = queue.peek();
        System.out.println(peek); // null

   
   
--------------------------------------

Deque Methods (FIFO)


--------------------------------------

Mixing FIFO and LIFO methods over a Deque's LinkedList



--------------------------------------