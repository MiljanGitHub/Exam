Collections
                 __________         _________
                /          Collection        \
               /               |              \
              /                |               \
             /                 |                \
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
            List             Queue              Set                                     Map
            /   \              |                /\                                      /\
           /     \             |               /  \                                    /  \
          /       \            |              /    \                                  /    \
       ArrayList   \         Deque         HashSet TreeSet                       HashMap  TreeMap
                    \         /
                     \       /
                    LinkedList

--------------------------------------

Diamond operator


List<Integer> list = new ArrayList<>(); //DOES COMPILE
Map<Long,List<Integer>> mapOfLists = new HashMap<>(); //DOES COMPILE

List<> list = new ArrayList<Integer>(); // DOES NOT COMPILE
class InvalidUse {
 void use(List<> data) {} // DOES NOT COMPILE
}

--------------------------------------

Methods available in Collection interface (9)

- public boolean add(E element)
- public boolean remove(Object object) //Be careful this is overloaded in List, Queue...
- public boolean isEmpty()
- public int size()
- public void clear() 
- public boolean contains(Object object)
- public boolean removeIf(Predicate<? super E> filter)
- public void forEach(Consumer<? super T> action)
- public boolean equals(Object object)

		(1)												   (2)													  (3)	
	    add							|			          remove								| 			  convenience 
									|															|	
public boolean add(E element)		|	public boolean remove(Object object)					|		public boolean isEmpty()
									|	public void clear()										|		public int size()
									|	public boolean removeIf(Predicate<? super E> filter)	|		public boolean contains(Object object)
									|														    |       public void forEach(Consumer<? super T> action)
									|															|		public boolean equals(Object object)
	



--------------------------------------

The List Interface

- ordered
- allows duplicates
- index based

Comparing ArrayList and LinkedList

ArrayList:

Good at: getting objects / accessing / reading(in constant time) (i.e. Good at READING)
Bad at: adding and removing (i.e. Bad at WRITING)

LinkedList
* additional methods to facilitate adding or removing from the beginning and/or end of the list

Good at: adding and removing 
Bad at:  getting objects / accessing / reading / *dealing with an arbitrary index takes linear time

--------------------------------------

Factory methods

Factory methods to create a List: Arrays.asList(varargs); | List.of(varargs); | List.copyOf(collection);

!!! Arrays.asList(varargs); !!! ---> So called "List view";

"List view" -> - If SIZE is changed either to array (although this is not possible) or to the list (this is possible) then UnsupportedOperationException is thrown!!!
			   - Gives immutable list in terms of size;
			   - *** Since it is so called "List view", we can modify and replace elements in an array or in a list, those changes will automatically be reflected on the other collection. ***

Examples:
	- calling: 'public boolean add(E element)' from Collection -> UnsupportedOperationException
	- calling: 'public boolean remove(Object object)' from Collection -> UnsupportedOperationException
    - calling: 'public E set(int index, E e) [Replaces element at index and returns original. May throw IndexOutOfBoundsException if index is invalid.]' from List -> UnsupportedOperationException

Examples:
		Replacing using set():
		
	    String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        String oldValueAtIndex1Unused = stringList.set(1, null); //replacing here
        System.out.println(Arrays.toString(arr1)); //[a, null]
		
		Modifyig via array:
		
		String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        arr1[0] = "c  //modifying here
        System.out.println(stringList);// [c, b]


!!! List.of(varargs); !!!		
		
List.of(varargs/array); ---> returns FULL IMMUTABLE LIST
						- no adding of elements -> UnsupportedOperationException
						- no removing -> UnsupportedOperationException
						- no replacing (i.e. using set(int, E e) from List); -> UnsupportedOperationException

Examples:
	    Person p1 = new Person(1); Person p2 = new Person(2);
        final List<Person> of = List.of(p1, p2); // The 'of' list contains identical copies of references 'p1' and 'p2'; i.e. References from 'of' and ('p1' and 'p2') are pointing to same objects, respectivly
        System.out.println(p2 == of.get(1)); //true
        of.get(1).id = 22;
        System.out.println(p2); //Person{id=22}
Examples:
		List.of(); //DOES COMPILE
		List.of(1, null); //Exception

!!! List.copyOf(collection); !!!			

Examples:
        final List<Person> copyOf = List.copyOf(personList);
        System.out.println(personList.get(0) == copyOf.get(0)); //true

		personList.remove(p1);
        System.out.println(personList.size()); //1
        System.out.println(copyOf.size()); //2

Method Description 			Can add elements?		Can delete elements?		Can replace elements?

Arrays.asList(varargs/array)    NO							NO							YES

List.of(varargs);				NO 						 	NO							NO

List.copyOf(collection);  		NO 						 	NO							NO

**At this point it would be good to repeat following methods: list.toArray(); list.toArray(someOtherArr); **
--------------------------------------

Creating a List with a Constructor

var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10); //ArrayList has this constructor not LinkedList
var linked2 = new LinkedList<Integer>(100); //DOES NOT COMPILE
--------------------------------------

Using var with ArrayList

var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE; The type of var is ArrayList<Object>

--------------------------------------

Working with List Methods

Beside methods in Collection, here are methods from List interface:

 - public void add(int index, E element) //its not like add(E e) from Collection; this one is void and from Collection is boolean return type
		
		Example1:
		Person p1 = new Person(1); Person p2 = new Person(2);
        List<Person> personList =  new ArrayList<>();
        personList.add(p1); personList.add(p2);
        personList.add(3, new Person(3)); //IndexOutOfBoundsException: Index: 3, Size: 2
        System.out.println(personList);
		
		Example2:
		
		String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        String removedEl = list.remove(1); //list: [a, c]
        String oldReplacedElement = list.set(1, d); //removedEl: c; list: [a, d]
        if (list.add(e)) System.out.println(list); //list: [a, d, e]

		Example3:
        String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        System.out.println(list); //[a, b, c]
        list.add(2, d); //shifts
        System.out.println(list); // [a, b, d, c]
        list.add(3, e);
        System.out.println(list); //[a, b, d, e, c]
	
 - public E get(int index) //Explained above
 - public E remove(int index) //Explained above
 - public E set(int index, E e)  // Explained above: Think of it as 'set' as doing 'replacing' //THERE IS NO replace(1, E e) method!!!
 - public default void replaceAll(UnaryOperator<E> op)
	    String x = "aaf";
        list.replaceAll(String::new); //DOES COMPILE
        list.replaceAll(x::concat); //DOES COMPILE
        list.replaceAll(String::concat); //DOES NOT COMPILE
        list.replaceAll(el -> el.replace("a", "b"));
 
 - public default void sort(Comparator<? super E> c)
	
	3: List<String> bunnies = new ArrayList<>();
	4: bunnies.add("long ear");
	5: bunnies.add("floppy");
	6: bunnies.add("hoppy");
	7: System.out.println(bunnies); // [long ear, floppy, hoppy]
	8: bunnies.sort((b1, b2) -> b1.compareTo(b2));
	9: System.out.println(bunnies); // [floppy, hoppy, long ear]
 
--------------------------------------

Set Methods 

Set<Character> letters = Set.of('z', 'o', 'o'); //Set.of(varargs/array); IMMUTABLE
Set<Character> copy = Set.copyOf(letters); //Set.copyOf(Collection<? extends E> coll); IMMUTABLE

3: Set<Integer> set = new HashSet<>();
4: boolean b1 = set.add(66); // true
5: boolean b2 = set.add(10); // true
6: boolean b3 = set.add(66); // false
7: boolean b4 = set.add(8); // true
8: set.forEach(System.out::println);
This code prints three lines:
66
8
10

--------------------------------------

Queue and Deque Interfaces

	 Queue (FIFO)
	  /|\
	   |
	   |
     Deque (FIFO) //*it may use LIFO methods pop()/push(E e)
	  /|\
	   |
	   |	    
   LinkedList + (it should be obvious that LinkedList implements List)
   
--------------------------------------
   
Queue<String> queue = new LinkedList<>();//DOES COMPILE
Deque<String> deque =  new LinkedList<>(); //DOES COMPILE
LinkedList<String> linkedList =  new LinkedList<>(); //DOES COMPILE
List<String> list = new LinkedList<>();    //DOES COMPILE

--------------------------------------
Queue Methods

 - public boolean add(E e) //Adding; From Collection

	Example1:
	
	Queue<String> queue = new LinkedList<>();
	queue.add("a");  queue.add("b");  //it adds elements to the end
	System.out.println(queue); [a,b]
	queue.add(null); //DOES NOT THROW EXCEPTION
	
 - public boolean offer(E e) //Adding; From Queue

	Example1:

    queue.add("a");  queue.add("b");  queue.add("c");
    queue.offer("a");
    System.out.println(queue);  // [a, b, c, a]

**add(E e) and offer(E e) are very simmilar in whihc that both are adding elements to the back of the list.	

 - public E remove() //Removing; It MAY throw Exception
 
Note: there is a 'public boolean remove(Object object)' from Collections which returns 'boolean' and remove() from Queue returns which returns first inserted element from Queue removes it
	  With remove() from Queue, we got no parameters to pass to the method, which means that it returns removed element, and in accordance with FIFO, it will return "first out", that is, first inserted element
	  
	  Example1:
	  
	    queue.add("a");  queue.add("b");  queue.add("c");
        boolean isRemovedElementByUsingCollectionRemoveMethod = queue.remove("a"); //true
        String removedElementByUsingDequeRemoveMethod = queue.remove(); 
        System.out.println(removedElementByUsingDequeRemoveMethod); //b
        System.out.println(queue); //[c]
	 
	  Example2:
	  
	  Queue<String> queue = new LinkedList<>();
	  String removedElementByUsingDequeRemoveMethod = queue.remove(); // !!! Throws exception if Queue is empty; 
																	 //It should be obvious that remove(Object o) from Collection returns boolean, 
																	//so no Exception will be throw if element we are trying to remove is not present
		
		
 - public E poll() //Removing; It DOES NOT throw Exception
		
	  Example1:
	  
        Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String poll = queue.poll();
        System.out.println(poll); //a
        System.out.println(queue); //[b, c]	  

	  Example2:		
		
		Queue<String> queue = new LinkedList<>();
        final String poll = queue.poll(); // null
		
	
 - public E element()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String element = queue.element();
        System.out.println(element); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String element = queue.element(); //Throws Exception

 - public E peek()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String peek = queue.peek();
        System.out.println(peek); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String peek = queue.peek();
        System.out.println(peek); // null

   
   
--------------------------------------

Deque Methods (FIFO)

        //Single deque methods; regular deque

        //Don't forget Deque is "double-ended" Queue; it has: 
		
		
				*******************************************************
Front ->		* HEAD--element1---element2--- ... ---elementN---TAIL *			<- End/Back
				*******************************************************
		
		
        //Methods inherited from Queue [remove() and poll()] and [element() and peek()] are head-oriented.
        //Methods from Deque class can still use those and have its own for head (suffixed "First") and for tail (suffixed "Last")
		
         Deque<Integer> deque = new LinkedList<>(); //This is FIFO, but if used Stack's methods like pop() and push(E e), then its LIFO
        
		//add
        deque.add(1); //[1]
        deque.addFirst(0); //[0, 1]
        deque.addLast(2); //[0, 1, 2]

        deque.offer(3); //[0,1,2,3]
        deque.offerFirst(-1); //[-1, 0,1,2,3]
        deque.offerLast(4); //[-1, 0, 1, 2, 3, 4]

        //remove
        Integer minusOne = deque.remove(); // -1; [0, 1, 2, 3, 4]
        Integer zero = deque.removeFirst(); // 0; [1, 2, 3, 4]
        Integer four = deque.removeLast(); // 4; [1, 2, 3]

        // poll(); pollFirst(); pollLast(); Operates same as respective remove() methods

        //gets
        Integer one = deque.element(); //1; [1, 2, 3]
        Integer three = deque.getLast(); // 3; [1, 2, 3] getLast() is supposed to be equivalent with "elementFirst()";
        Integer oneAgain = deque.getFirst(); //1; [1, 2, 3]

        //peek(); peekFirst(); peekLast(); ; Operates same as respective element()/get() methods
--------------------------------------

Mixing FIFO and LIFO methods over a Deque's LinkedList

        Deque<Integer> deque = new LinkedList<>();

        deque.add(1); //[1]
        deque.add(2); //
        deque.addFirst(3);

        deque.push(-1);
        deque.push(-2); // -2,-1,3,1,2
        System.out.println(deque.remove()); //-2
        System.out.println(deque.pop()); //-1
		
Add to the front/top 'public void push(E e)'
Remove from the front/top 'public E pop()'

--------------------------------------

Map Interface


Factory Methods

- Map.of("key1", "value1", "key2", "value2");

- Map.ofEntries(
	Map.entry("key1", "value1"),
	Map.entry("key2", "value2"));

- Map.copyOf(anotherMap);

--------------------------------------

- A TreeMap stores the keys in a sorted tree structure. The main benefit is that the keys are always in sorted order. Like a TreeSet. No null

--------------------------------------

Working with Map Methods

 
 Given that Map doesn’t extend Collection, more methods are specified on the Map interface. 
 
 Mnemonics for Map methods
 
				 J L
	CEFG		I K M 
	3112		1 1 1
 
 
"O" PRS			V
	231			1
	

********
* CEFG *
* 3112 *
********


C - boolean containsKey(Object key) 
C - boolean containsValue(Object value)
C - void 	clear()

E - Set<Map.Entry<K,V>> entrySet()

F - void forEach(BiConsumer<K key, V value> biconsumer)

G - V get(Object key)
G - V getOrDefault(Object key, V value)

*********
*  J L  *
* I K M *
* 1 1 1 *
*********

I - boolean isEmpty()

K - Set<K> keySet()

M - V merge(K key, V value, Function(<V oldValue, V newValue, V returnTypeOfValue> func)) //Sets value if key not set. Runs function if key is set, to determine new value. Removes if value is null.

	*******
"O" * PRS *
	* 231 *
	*******

P - V put(K key)
P - V putIfAbsent(K key, V defaultValue)

R - V    remove(Object key)
R - V 	 replace(K key, V value)
R - void replaceAll(BiFunction<K, V, V> func)

S - int size()

*****
* V *
* 1 * 
*****

V - Collection<V> values()

Example Methods for Each method:


1. boolean containsKey(Object key) 

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.containsKey(1)); //true
        System.out.println(map.containsKey("b")); //false
        System.out.println(map.containsKey(new Student())); //false

2. boolean containsValue(Object value)

Example1:
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.containsValue(1)); //false
        System.out.println(map.containsValue("b")); //true
        System.out.println(map.containsValue(new Student())); //false

3. void clear()

Example1:
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
		map.clear();
		System.out.println(map.size()); //0

4. Set<Map.Entry<K,V>> entrySet()

Example1:

	    Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        Set<Map.Entry<Integer, String>> entrySet = map.entrySet();
        System.out.println(entrySet);
		
		map.entrySet().forEach(e ->	System.out.println(e.getKey() + " " + e.getValue()));

5. void forEach(BiConsumer<K key, V value> biconsumer)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        
        map.forEach((var key, var val) -> {}); //DOES COMPILE 
        map.forEach((var key, var val) -> {
            System.out.println(key + " " + val);
        }); //DOES COMPILE 
        
        class Printer{
             void print(Object o1, Object o2){
                System.out.println(o1 + " " + o2);
            }
        }
        Printer p = new Printer();
        map.forEach(p::print); //DOES COMPILE 

6. V get(Object key)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        String v1 = map.get(1); // "a"
        CharSequence v2 = map.get(2); //DOES COMPILE   
        class Student{};       
        Student x = map.get(1); //DOES NOT COMPILE       
        StringBuilder x1 = map.get(1); //DOES NOT COMPILE       
        Object x2 = map.get(new Student()); //DOES COMPILE
		System.out.println(map.get(new Student())); // null


7. V getOrDefault(Object key, V defaultValue)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        class Student{};
        System.out.println(map.getOrDefault(1, "c")); // "a"
        System.out.println(map.getOrDefault(1, new Student())); // DOES NOT COMPILE
        System.out.println(map.getOrDefault(5, "c")); // "c"
        System.out.println(map.getOrDefault(new Student(), "f")); // "f"
		System.out.println(map.getOrDefault(3, "d")); //null

8. boolean isEmpty()

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.isEmpty()); //false
        map.clear();
        System.out.println(map.isEmpty()); //true

9. Set<K> keySet()

Example1:

		Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        Set<Integer> s = map.keySet(); //DOES COMPILE
        Set<Object> s1 = map.keySet(); //DOES NOT COMPILE

10. V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)

Example1:
        //There is no key mapping
        HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", 150);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Shirt", 100, (oldValue, newValue) -> {
            System.out.println("never gets executed");
            return oldValue + newValue;
        }); //Integer::sum
        System.out.println("Price of Shirt: " + returnedValue);//100
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=150, Shirt=100, Bag=300, Shoes=200} //newValue provided will be taken as a value for a key

        
        //There is existing key mapping to non-null value -> recomputing Function has been applied (in it, we are using new value)
       HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", 150);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Pant", 75, (oldValue, newValue) ->  oldValue + newValue); //Integer::sum
        System.out.println("Price of Pant: " + returnedValue); //225
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=225, Bag=300, Shoes=200} //recomputing Function takes precedence over newValue


        //There is existing key mapping to null value -> so newValue provided will be mapped to existing key; recomputing Function not called
        HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", null);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Pant", 75, (oldValue, newValue) ->  oldValue + newValue); //Integer::sum
        System.out.println("Price of Pant: " + returnedValue); //75
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=75, Bag=300, Shoes=200} //recomputing Function takes precedence over newValue
		
		newValue ** must not be null
		
		merge returns computed or passed value
		
		What happens when the mapping function is called and returns null. The key is removed from the map when this happens:
		
		BiFunction<String, String, String> mapper = (v1, v2) -> null;
		Map<String, String> favorites = new HashMap<>();
		favorites.put("Jenny", "Bus Tour");
		favorites.put("Tom", "Bus Tour");
		favorites.merge("Jenny", "Skyride", mapper);
		favorites.merge("Sam", "Skyride", mapper);
		System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}

11. V put(K key)

Example1:

        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
        String y = map.put(2, "b"); // "b"
        Object u = map.put(123, "asdasdaff"); //DOES COMPILE

        map.put(2, "g"); // {1=a, 2=g, 123=asdasdaff}
        map.put(null, null); // {null=null, 1=a, 2=g, 123=asdasdaff}

12. V putIfAbsent(K key, V value)

Example1:
        class Student{}
        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
		
        String y = map.putIfAbsent(2, "b");
        System.out.println(y); //null
        System.out.println(map); //{1=a, 2=b}
		
        // Object u = map.putIfAbsent(123, new Student()); //DOES NOT COMPILE

        var x12 = map.putIfAbsent(null, null); 
        System.out.println(x12); //null
        System.out.println(map); // {null=null, 1=a, 2=b}

        var xd = map.putIfAbsent(1, "c");
        System.out.println(xd); // "a" OLD VALUE RETURNED
        System.out.println(map); //{null=null, 1=a, 2=b}

        var k = map.putIfAbsent(4, null);
        System.out.println(k); //null
        System.out.println(map); //{null=null, 1=a, 2=b, 4=null}

        var t = map.putIfAbsent(4, "h"); //**** IMPORTANT EXAMPLE
        System.out.println(t); //null
        System.out.println(map); //{null=null, 1=a, 2=b, 4=h} //**** IMPORTANT EXAMPLE
		
		Map<String, String> favorites = new HashMap<>();
		favorites.put("Jenny", "Bus Tour");
		favorites.put("Tom", null);
		favorites.putIfAbsent("Jenny", "Tram");
		favorites.putIfAbsent("Sam", "Tram");
		favorites.putIfAbsent("Tom", "Tram");
		System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}
		
13.  V remove(Object key)

Example1:

        class Student{}
        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"

        String val = map.remove(1);// "a"
        var x1 = map.put(2, "b");
        System.out.println(map.remove(new Student())); //null

14. V replace(K key, V value)

Example1:
		
		class Student{}
        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
        var x1 = map.put(2, "b"); //"b"

        var x2 = map.replace(4, null);
        System.out.println(x2); //null
        System.out.println(map); //{1=a, 2=b}

        final String b = map.replace(2, "c");
        System.out.println(b); //b
        System.out.println(map); //{1=a, 2=c}

        map.put(5, null); //Important example; 'replace(K key, V value)' behaves similar to 'V putIfAbsent(K key, V defaultValue)' when it comes to mapping which contains 'null' as value for given key
        String var = map.replace(5, "d");
        System.out.println(var); //null
        System.out.println(map); //{1=a, 2=c, 5=d}
        map.replace(55, new Student()); //DOES NOT COMPILE
        map.replace(new Student(), 55 ); //DOES NOT COMPILE
		
15. void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)

Example1:

        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
        var x1 = map.put(2, "b"); //"b"

        map.replaceAll( (key, val) -> val + key); //DOES COMPILE
        //Object res = map.replaceAll( (key, val) -> val + key); //DOES NOT COMPILE
		
16. int size()

Example1:
	
	    Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
        var x1 = map.put(2, "b"); //"b"
        System.out.println(map.size()); //2

17. Collection<V> values()

Example1:

        Map<Integer, String> map = new HashMap<>();
        var x = map.put(1, "a"); // "a"
        var x1 = map.put(2, "b");
        System.out.println(map.values()); //[a, b]
		for (Object o : map.values()){} //DOES COMPILE

--------------------------------------

Type	Can contain duplicate elements?		 Elements always ordered? 			Has keys and values? 			Must add/remove in specific order?

List 			Yes 								Yes (by index) 						No 										No
Map 			Yes (for values) 					No 									Yes 									No
Queue 			Yes	 								Yes (retrieved in defined order) 	No 										Yes
Set 			No 									No 									No 										No


Type			Java Collections Framework interface 		 Sorted? 		Calls hashCode? 		Calls compareTo?

ArrayDeque 					Deque 							   No 				No 						 No
ArrayList 				    List 							   No 				No 						 No
HashMap 					Map 							   No 				Yes 					 No
HashSet 				    Set 							   No 				Yes 					 No
LinkedList					List, Deque 					   No 				No 						 No
TreeMap 					Map 							   Yes              No 						 Yes
TreeSet 				    Set 							   Yes 				No 						 Yes



--------------------------------------


Comparable Interface -> the interface which is directly implemented by the class; it DOES NOT NEED an import since it is in java.lang; package


public interface Comparable<T> {
 int compareTo(T o);
}



import java.lang.*; //COMPAREBLE -> is from java.lang.*!!!!!
public class Duck implements Comparable<Duck> {

 private String name;
 
 public Duck(String name) {
	this.name = name;
 }
 
 public String toString() { // use readable output
	return name;
 }
 
 public int compareTo(Duck d) {
	//IF -1: Current object is "lesser"
	//IF 1: Current object is "greater"
	//IF 0: objects are equal in tersm of compareTo
	return name.compareTo(d.name); // sorts ascendingly by name
 }
 public static void main(String[] args) {
	var ducks = new ArrayList<Duck>();
	ducks.add(new Duck("Quack"));
	ducks.add(new Duck("Puddles"));
	Collections.sort(ducks); // sort by name
	System.out.println(ducks); // [Puddles, Quack]
 }
}


There are three rules to know:
■ The number 0 is returned when the current object is equivalent to the argument to compareTo().
■ A negative number (less than 0) is returned when the current object is smaller than the argument to compareTo().
■ A positive number (greater than 0) is returned when the current object is larger than the argument to compareTo().

public int compareTo(Animal otherAnimal) {
	return id - otherAnimal.id; // ******** sorts ascending by id
}
 // x.apply(null, null); //BiFunction<Duck, Duck, Integer> x = (d1, d2) -> d1.compareTo(d2); //DOES COMPILE
//Ako od "this" objekta uzimamo properti i njega koristimo sa desne strane znaka "-" odnosno poredjanja sa argumentom "otherAnimal" znaci da je ascending order /|\
						

Legacy

public class LegacyDuck implements Comparable {
 private String name;
 public int compareTo(Object obj) {
 LegacyDuck d = (LegacyDuck) obj; // cast because no generics
 return name.compareTo(d.name);
 }
}						|
																																								
Keeping compareTo() and equals() Consistent

A natural ordering that uses compareTo() is said to be consistent with equals if, and only if, x.equals(y) is true whenever x.compareTo(y) equals 0.																																							

For example, the following Product class defines a compareTo() method that is not consistent with equals:

public class Product implements Comparable<Product> {
 private int id;
 private String name;
 public int hashCode() { return id; }
 public boolean equals(Object obj) {
	if(!(obj instanceof Product)) return false;
	var other = (Product) obj;
	return this.id == other.id;
 }
 public int compareTo(Product obj) {
	return this.name.compareTo(obj.name);
 }
}

//For instance, Product={id=1, name="pera"} and Product={id=2, name="pera"}

equals => false 
compareTo => 0 


Comparable - Important stuff:

1. java.lang
2. Implemented by a class
3. Generic <T>
4. int compareTo(T t)
5. -1 this is lesser; 1 this is greater; 0 equal
6. Used by TreeMap and TreeSet


Comparator -> the interface which is supposed to be instantiated like a class (that is, NOT to be implemented by a domain class/entity); it DOES NEED an import since it is in java.util.Comparator; package
			  cannot use Comparator without an import statement



import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Duck implements Comparable<Duck> {
private String name;
private int weight;

// Assume getters/setters/constructors provided

 public String toString() { return name; }

 public int compareTo(Duck d) {
 return name.compareTo(d.name);
 }

 public static void main(String[] args) {
	Comparator<Duck> byWeight = new Comparator<Duck>() {
	public int compare(Duck d1, Duck d2) {
		return d1.getWeight()-d2.getWeight();
	}};
	var ducks = new ArrayList<Duck>();
	ducks.add(new Duck("Quack", 7));
	ducks.add(new Duck("Puddles", 10));
	Collections.sort(ducks);
	System.out.println(ducks); // [Puddles, Quack]
	Collections.sort(ducks, byWeight);
	System.out.println(ducks); // [Quack, Puddles]
 }
}


@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
	
Comparator is a functional interface, so this is ok:

1. Comparator<Duck> byWeight = (d1, d2) -> d1.getWeight()-d2.getWeight();
OR
2. Comparator<Duck> byWeight = Comparator.comparing(Duck::getWeight);

//Comparator.comparing ->  Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)


Comparison of Comparable and Comparator

Difference 											Comparable 								Comparator				 
Package name 										 java.lang 								 java.util
Interface must be implemented by class comparing?	   Yes 										No
Method name in interface 							 compareTo()							 compare()
Number of parameters									 1 										2
Common to declare using a lambda 						No									   Yes

The exam will try to trick you by mixing up the two (Comparable and Comparator) and seeing if you can catch it. Do you see why this doesn’t compile?

var byWeight = new Comparator<Duck>() { // DOES NOT COMPILE
 public int compareTo(Duck d1, Duck d2) {
 return d1.getWeight()-d2.getWeight();
 }
};

My mnemonic for memorizing SAM methods of Comparable and Comparator:

Comparable -> int compareTo(T other); must remember that is inside DOMAIN class and it expects one parameter; So: 'compare TO, compare TO something (single) other'
Comparator -> not meant to be implemented by domain class it is an outside object (by that I mean "MyComparator implements Comparator<T>" and it expects two object so: compare(Object o1, Object o2) 



Exploring Comparator's convenience methods and Comparing Domain Class by Multiple Fields
Domain classes:

class Student{}
public class Duck {
    private int weight;
    private String species;
	private Student student;
	private long width;
    private double height;
	//ommited getters/setters/constructors
}

1. Creating Comparator (Static methods)
Comparator<Duck> comparator = Comparator.comparing(Duck::getSpecies); //DOES  COMPILE
Comparator<Duck> comparator = Comparator.comparing(Duck::getStudent);  //DOES NOT COMPILE; if Student implemented Comparable<Student> then this line would compile
Comparator<Duck> comparator1 = Comparator.comparingInt(Duck::getWeight); 
Comparator<Duck> comparator2 = Comparator.comparingLong(Duck::getWidth);
Comparator<Duck> comparator3 = Comparator.comparingDouble(Duck::getHeight); //We could pass getWidth or getWeight, "numeric type promotion"

 final Comparator<Duck> tComparator = Comparator.naturalOrder(); //DOES NOT COMPILE; if Duck  were to implemented Comparable<Duck> then this line would compile
 Comparator<Duck> cc = comparator1.naturalOrder();  //DOES NOT COMPILE; Even if the Duck implemented Comparable<Duck> this would not compile since naturalOrder() is STATIC!!!!!!!!!!
 
 Comparator<Duck> cc = Comparator.reverseOrder(); //sam goes as for naturalOrder(); Must implemente Comparable
 
 
2. Chaining methods (need an instance) for Comparator (Default methods)

Comparator<Duck> comp = Comparator.comparing(Duck::getWidth);
final Comparator comparator = Comparator.thenComparing(comp); //DOES NOT COMPILE; thenComparingXYZ(Comparator other) are DEFAULT (not static) methods so they need an instance
final Comparator comparator1 = comp.thenComparing(Duck::getSpecies);

Comparator<Duck> compX = Comparator.thenComparingDouble(function); //DOES NOT COMPILE;
final Comparator comparatorY = comp.thenComparingDouble(Duck::getWidth);    //DOES COMPILE;

**  Comparator<Duck> cc = comparator1.reversed(); //DOES COMPILE;

--------------------------------------

Sorting ascending and descending

class Rabbit{
	public id;
}

MyRabbitSorter implementes Comparator<Rabbit>{
	@Override
	public int compare(Rabbit r1, Rabbit r2){
		return r2.id - r1.id;  //DSC
		//return r1.id - r2.id;  //ASC
	}
}

Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id; //ASC
Comparator<Rabbit> c = (r1, r2) -> r2.id - r1.id; //DSC

--------------------------------------

Sorting ( Collections.sort() ) and Searching ( Collections.binarySearch() )


Sorting

*** The Collections.sort() method uses the compareTo() method to sort. It expects the objects to be sorted to be Comparable.

Example1:
public class RabbitDemo {
    static record RabbitRun(int id) { }

    public static void main(String[] args) {
        Comparator<RabbitRun> c = Comparator.comparingInt(RabbitRun::id);
        Collections.reverse(List.of(new RabbitRun(1))); //DOES COMPILE when using Non-Comparable with reverese()
    }
}

Example2:
class Rabbit{}
var list = new ArrayList<Rabbit>();
Collections.sort(list); //DOES NOT COMPILE; Rabbit must be instance of Comparable

Or, using another way:

Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id;
Collections.sort(rabbits, c); //Rabbit DOES NOT need to be Comparable

Example3:
Collections.reverse(rabbits); //Reverses the order of the elements in the specified list. No need for Comparable nor Comparator it just swap places in a list

Example4:
List<Integer> list = Arrays.asList(6,9,1,8);
Collections.sort(list); //DOES COMPILE since Integer implements Comparable<Integer>


Searching

//just review
11: List<Integer> list = Arrays.asList(6,9,1,8);
12: Collections.sort(list); // [1, 6, 8, 9]
13: System.out.println(Collections.binarySearch(list, 6)); // 1
14: System.out.println(Collections.binarySearch(list, 3)); // -2

Example1:

        var names = Arrays.asList("Zrx", "Fluffy",  "Aoppy"); //While the result of calling binarySearch() on an improperly sorted list is undefined;
		//No sorting here
        Comparator<String> c = Comparator.reverseOrder();
        System.out.println(Collections.binarySearch(names, "Koppy", c)); //undefined number

Example2:

Going back to our Rabbit that does not implement Comparable, we try to add it to a TreeSet:
2: public class UseTreeSet {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: Set<Duck> ducks = new TreeSet<>(); //Duck implements Comparable
6: ducks.add(new Duck("Puddles"));
7:
8: Set<Rabbit> rabbits = new TreeSet<>();
9: rabbits.add(new Rabbit()); // ClassCastException; but it DOES COMPILE; Exception in thread "main" java.lang.ClassCastException: class Rabbit cannot be cast to class java.lang.Comparable
10: } }

Example3:

Instantiating TreeSet which with comparator
8: Set<Rabbit> rabbits = new TreeSet<>((r1, r2) -> r1.id - r2.id);
9: rabbits.add(new Rabbit()); //No ClassCastException; since we provided Comparator

--------------------------------------

Generics

Type Erasure - 

public class Crate<T> {
 private T contents;
 public T lookInCrate() {
 return contents;
 }
 public void packCrate(T contents) {
 this.contents = contents;
 }
}

After the code compiles, your generics are just Object types:

public class Crate {
 private Object contents;
 public Object lookInCrate() {
 return contents;
 }
 public void packCrate(Object contents) {
 this.contents = contents;
 }
 }
 
 

This process of removing the generics syntax from your code is referred to as type erasure.

Example1:

public class A {
 protected void chew(List<Object> input) {} //After compilation, translated to: "protected void chew(List input) {}"
 protected void chew(List<Double> input) {} //After compilation, translated to: "protected void chew(List input) {}", this line DOES NOT COMPILE
}

Nor does this goes through:

public class LongTailAnimal2 {
 protected void chew(List<StringBuilder> input) {} //After compilation, translated to: "protected void chew(List input) {}"
 protected void chew(List<Double> input) {} //After compilation, translated to: "protected void chew(List input) {}", this line DOES NOT COMPILE
}

Example2:

You can’t overload a generic method from a parent class

public class LongTailAnimal {
 protected void chew(List<Object> input) {}
}
public class Anteater extends LongTailAnimal {
 protected void chew(List<Double> input) {} // DOES NOT COMPILE
}

Translation for classes above: NOT GOOD!!! This does compile

class LongTailAnimal {
 protected void chew(List input) {}
}
public class Anteater extends LongTailAnimal {
 protected void chew(List input) {} // DOES NOT COMPILE
 //In the compiled form (this form), the generic type is dropped, and it appears as an invalid overloaded method, such as the ones in LongTailAnimal class.
}

Example3:

class LongTailAnimal {
 protected void chew(List<Object> input) {} //DOES COMPILE
}

public class Anteater extends LongTailAnimal {
 protected void chew(List<Object> input) {} //DOES COMPILE
 protected void chew(ArrayList<Double> input) {} //DOES COMPILE
}