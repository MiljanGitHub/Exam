Collections
                 __________         _________
                /          Collection        \
               /               |              \
              /                |               \
             /                 |                \
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
             |                 |                 |
            List             Queue              Set                                     Map
            /   \              |                /\                                      /\
           /     \             |               /  \                                    /  \
          /       \            |              /    \                                  /    \
       ArrayList   \         Deque         HashSet TreeSet                       HashMap  TreeMap
                    \         /
                     \       /
                    LinkedList

--------------------------------------

Diamond operator


List<Integer> list = new ArrayList<>(); //DOES COMPILE
Map<Long,List<Integer>> mapOfLists = new HashMap<>(); //DOES COMPILE

List<> list = new ArrayList<Integer>(); // DOES NOT COMPILE
class InvalidUse {
 void use(List<> data) {} // DOES NOT COMPILE
}

--------------------------------------

Methods available in Collection interface 

- public boolean add(E element)
- public boolean remove(Object object) //Be careful this is overloaded in List, Queue...
- public boolean isEmpty()
- public int size()
- public void clear() 
- public boolean contains(Object object)
- public boolean removeIf(Predicate<? super E> filter)
- public void forEach(Consumer<? super T> action)
- public boolean equals(Object object)

--------------------------------------

The List Interface

- ordered
- allows duplicates
- index based

Comparing ArrayList and LinkedList

ArrayList:

Good at: getting objects / accessing / reading(in constant time) (i.e. Good at READING)
Bad at: adding and removing (i.e. Bad at WRITING)

LinkedList
* additional methods to facilitate adding or removing from the beginning and/or end of the list

Good at: adding and removing (i.e. Bad at WRITING
Bad at:  getting objects / accessing / reading / *dealing with an arbitrary index takes linear time

--------------------------------------

Factory methods

Factory methods to create a List: Arrays.asList(varargs); | List.of(varargs); | List.copyOf(collection);

!!! Arrays.asList(varargs); !!! ---> So called "List view";

"List view" -> - If SIZE is changed either to array (although this is not possible) or to the list (this is possible) then UnsupportedOperationException is thrown!!!
			   - Gives immutable list in terms of size;
			   - *** Since it is so called "List view", we can modify and replace elements in an array or in a list, those changes will automatically be reflected on the other collection. ***

Examples:
	- calling: 'public boolean add(E element)' from Collection -> UnsupportedOperationException
	- calling: 'public boolean remove(Object object)' from Collection -> UnsupportedOperationException
    - calling: 'public E set(int index, E e) [Replaces element at index and returns original. May throw IndexOutOfBoundsException if index is invalid.]' from List -> UnsupportedOperationException

Examples:
		Replacing using set():
		
	    String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        String oldValueAtIndex1Unused = stringList.set(1, null); //replacing here
        System.out.println(Arrays.toString(arr1)); //[a, null]
		
		Modifyig via array:
		
		String[] arr1 = {"a", "b"};
        List<String> stringList = Arrays.asList(arr1);
        arr1[0] = "c  //modifying here
        System.out.println(stringList);// [c, b]


!!! List.of(varargs); !!!		
		
List.of(varargs/array); ---> returns FULL IMMUTABLE LIST
						- no adding of elements -> UnsupportedOperationException
						- no removing -> UnsupportedOperationException
						- no replacing (i.e. using set(int, E e) from List); -> UnsupportedOperationException

Examples:
	    Person p1 = new Person(1); Person p2 = new Person(2);
        final List<Person> of = List.of(p1, p2); // The 'of' list contains identical copies of references 'p1' and 'p2'; i.e. References from 'of' and ('p1' and 'p2') are pointing to same objects, respectivly
        System.out.println(p2 == of.get(1)); //true
        of.get(1).id = 22;
        System.out.println(p2); //Person{id=22}
Examples:
		List.of(); //DOES COMPILE
		List.of(1, null); //Exception

!!! List.copyOf(collection); !!!			

Examples:
        final List<Person> copyOf = List.copyOf(personList);
        System.out.println(personList.get(0) == copyOf.get(0)); //true

		personList.remove(p1);
        System.out.println(personList.size()); //1
        System.out.println(copyOf.size()); //2

Method Description 			Can add elements?		Can delete elements?		Can replace elements?

Arrays.asList(varargs/array)    NO							NO							YES

List.of(varargs);				NO 						 	NO							NO

List.copyOf(collection);  		NO 						 	NO							NO

**At this point it would be good to repeat following methods: list.toArray(); list.toArray(someOtherArr); **
--------------------------------------

Creating a List with a Constructor

var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
var list1 = new ArrayList<String>();
var list2 = new ArrayList<String>(list1);
var list3 = new ArrayList<String>(10); //ArrayList has this constructor not LinkedList
var linked2 = new LinkedList<Integer>(100); //DOES NOT COMPILE
--------------------------------------

Using var with ArrayList

var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE; The type of var is ArrayList<Object>

--------------------------------------

Working with List Methods

Beside methods in Collection, here are methods from List interface:

 - public void add(int index, E element) //its not like add(E e) from Collection; this one is void and from Collection is boolean return type
		
		Example1:
		Person p1 = new Person(1); Person p2 = new Person(2);
        List<Person> personList =  new ArrayList<>();
        personList.add(p1); personList.add(p2);
        personList.add(3, new Person(3)); //IndexOutOfBoundsException: Index: 3, Size: 2
        System.out.println(personList);
		
		Example2:
		
		String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        String removedEl = list.remove(1); //list: [a, c]
        String oldReplacedElement = list.set(1, d); //removedEl: c; list: [a, d]
        if (list.add(e)) System.out.println(list); //list: [a, d, e]

		Example3:
        String a = "a"; String b = "b"; String c = "c";  String d = "d"; String e = "e";
        List<String> list =  new ArrayList<>();
        list.add(a); list.add(b); list.add(c);

        System.out.println(list); //[a, b, c]
        list.add(2, d); //shifts
        System.out.println(list); // [a, b, d, c]
        list.add(3, e);
        System.out.println(list); //[a, b, d, e, c]
	
 - public E get(int index) //Explained above
 - public E remove(int index) //Explained above
 - public E set(int index, E e)  // Explained above: Think of it as 'set' as doing 'replacing'
 
 - public default void replaceAll(UnaryOperator<E> op)
	    String x = "aaf";
        list.replaceAll(String::new); //DOES COMPILE
        list.replaceAll(x::concat); //DOES COMPILE
        list.replaceAll(String::concat); //DOES NOT COMPILE
        list.replaceAll(el -> el.replace("a", "b"));
 
 - public default void sort(Comparator<? super E> c)
	
	//TODO
 
--------------------------------------

Set Methods 

Set<Character> letters = Set.of('z', 'o', 'o'); //Set.of(varargs/array); IMMUTABLE
Set<Character> copy = Set.copyOf(letters); //Set.copyOf(Collection<? extends E> coll); IMMUTABLE

3: Set<Integer> set = new HashSet<>();
4: boolean b1 = set.add(66); // true
5: boolean b2 = set.add(10); // true
6: boolean b3 = set.add(66); // false
7: boolean b4 = set.add(8); // true
8: set.forEach(System.out::println);
This code prints three lines:
66
8
10

--------------------------------------

Queue and Deque Interfaces

	 Queue (FIFO)
	  /|\
	   |
	   |
     Deque (FIFO) //*it may use LIFO methods pop()/push(E e)
	  /|\
	   |
	   |	    
   LinkedList + (it should be obvious that LinkedList implements List)
   
--------------------------------------
   
Queue<String> queue = new LinkedList<>();//DOES COMPILE
Deque<String> deque =  new LinkedList<>(); //DOES COMPILE
LinkedList<String> linkedList =  new LinkedList<>(); //DOES COMPILE
List<String> list = new LinkedList<>();    //DOES COMPILE

--------------------------------------
Queue Methods

 - public boolean add(E e) //Adding; From Collection

	Example1:
	
	Queue<String> queue = new LinkedList<>();
	queue.add("a");  queue.add("b");  //it adds elements to the end
	System.out.println(queue); [a,b]
	queue.add(null); //DOES NOT THROW EXCEPTION
	
 - public boolean offer(E e) //Adding; From Queue

	Example1:

    queue.add("a");  queue.add("b");  queue.add("c");
    queue.offer("a");
    System.out.println(queue);  // [a, b, c, a]

**add(E e) and offer(E e) are very simmilar in whihc that both are adding elements to the back of the list.	

 - public E remove() //Removing; It MAY throw Exception
 
Note: there is a 'public boolean remove(Object object)' from Collections which returns 'boolean' and remove() from Queue returns which returns first inserted element from Queue removes it
	  With remove() from Queue, we got no parameters to pass to the method, which means that it returns removed element, and in accordance with FIFO, it will return "first out", that is, first inserted element
	  
	  Example1:
	  
	    queue.add("a");  queue.add("b");  queue.add("c");
        boolean isRemovedElementByUsingCollectionRemoveMethod = queue.remove("a"); //true
        String removedElementByUsingDequeRemoveMethod = queue.remove(); 
        System.out.println(removedElementByUsingDequeRemoveMethod); //b
        System.out.println(queue); //[c]
	 
	  Example2:
	  
	  Queue<String> queue = new LinkedList<>();
	  String removedElementByUsingDequeRemoveMethod = queue.remove(); // !!! Throws exception if Queue is empty; 
																	 //It should be obvious that remove(Object o) from Collection returns boolean, 
																	//so no Exception will be throw if element we are trying to remove is not present
		
		
 - public E poll() //Removing; It DOES NOT throw Exception
		
	  Example1:
	  
        Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String poll = queue.poll();
        System.out.println(poll); //a
        System.out.println(queue); //[b, c]	  

	  Example2:		
		
		Queue<String> queue = new LinkedList<>();
        final String poll = queue.poll(); // null
		
	
 - public E element()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String element = queue.element();
        System.out.println(element); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String element = queue.element(); //Throws Exception

 - public E peek()

	Example1:
	
	    Queue<String> queue = new LinkedList<>();
        queue.add("a");  queue.add("b");  queue.add("c");
        final String peek = queue.peek();
        System.out.println(peek); //gets it 'a'
        System.out.println(queue); //[a, b, c]

	Example2:
	
	    Queue<String> queue = new LinkedList<>();
        final String peek = queue.peek();
        System.out.println(peek); // null

   
   
--------------------------------------

Deque Methods (FIFO)

        //Single deque methods; regular deque

        //Don't forget Deque is "double-ended" Queue; it has: 
		
		
				*******************************************************
Front ->		* HEAD--element1---element2--- ... ---elementN---TAIL *			<- End/Back
				*******************************************************
		
		
        //Methods inherited from Queue [remove() and poll()] and [element() and peek()] are head-oriented.
        //Methods from Deque class can still use those and have its own for head (suffixed "First") and for tail (suffixed "Last")
		
         Deque<Integer> deque = new LinkedList<>(); //This is FIFO, but if used Stack's methods like pop() and push(E e), then its LIFO
        
		//add
        deque.add(1); //[1]
        deque.addFirst(0); //[0, 1]
        deque.addLast(2); //[0, 1, 2]

        deque.offer(3); //[0,1,2,3]
        deque.offerFirst(-1); //[-1, 0,1,2,3]
        deque.offerLast(4); //[-1, 0, 1, 2, 3, 4]

        //remove
        Integer minusOne = deque.remove(); // -1; [0, 1, 2, 3, 4]
        Integer zero = deque.removeFirst(); // 0; [1, 2, 3, 4]
        Integer four = deque.removeLast(); // 4; [1, 2, 3]

        // poll(); pollFirst(); pollLast(); Operates same as respective remove() methods

        //gets
        Integer one = deque.element(); //1; [1, 2, 3]
        Integer three = deque.getLast(); // 3; [1, 2, 3] getLast() is supposed to be equivalent with "elementFirst()";
        Integer oneAgain = deque.getFirst(); //1; [1, 2, 3]

        //peek(); peekFirst(); peekLast(); ; Operates same as respective element()/get() methods
--------------------------------------

Mixing FIFO and LIFO methods over a Deque's LinkedList

        Deque<Integer> deque = new LinkedList<>();

        deque.add(1); //[1]
        deque.add(2); //
        deque.addFirst(3);

        deque.push(-1);
        deque.push(-2); // -2,-1,3,1,2
        System.out.println(deque.remove()); //-2
        System.out.println(deque.pop()); //-1
		
Add to the front/top 'public void push(E e)'
Remove from the front/top 'public E pop()'

--------------------------------------

Map Interface


Factory Methods

- Map.of("key1", "value1", "key2", "value2");

- Map.ofEntries(
	Map.entry("key1", "value1"),
	Map.entry("key2", "value2"));

- Map.copyOf(anotherMap);

--------------------------------------

- A TreeMap stores the keys in a sorted tree structure. The main benefit is that the keys are
always in sorted order. Like a TreeSet

--------------------------------------

Working with Map Methods

 
 Given that Map doesn’t extend Collection, more methods are specified on the Map interface. 
 
 Mnemonics for Map methods
 
				 J L
	CEFG		I K M 
	3112		1 1 1
 
 
"O" PRS			V
	231			1
	

********
* CEFG *
* 3112 *
********


C - boolean containsKey(Object key) 
C - boolean containsValue(Object value)
C - void 	clear()

E - Set<Map.Entry<K,V>> entrySet()

F - void forEach(BiConsumer<K key, V value> biconsumer)

G - V get(Object key)
G - V getOrDefault(Object key, V value)

*********
*  J L  *
* I K M *
* 1 1 1 *
*********

I - boolean isEmpty()

K - Set<K> keySet()

M - V merge(K key, V value, Function(<V, V, V> func)) //Sets value if key not set. Runs function if key is set, to determine new value. Removes if value is null.

	*******
"O" * PRS *
	* 231 *
	*******

P - V put(K key)
P - V putIfAbsent(K key, V defaultValue)

R - V    remove(Object key)
R - V 	 replace(K key, V value)
R - void replaceAll(BiFunction<K, V, V> func)

S - int size()

*****
* V *
* 1 * 
*****

V - Collection<V> values()

Example Methods for Each method:


1. boolean containsKey(Object key) 

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.containsKey(1)); //true
        System.out.println(map.containsKey("b")); //false
        System.out.println(map.containsKey(new Student())); //false

2. boolean containsValue(Object value)

Example1:
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.containsValue(1)); //false
        System.out.println(map.containsValue("b")); //true
        System.out.println(map.containsValue(new Student())); //false

3. void clear()

Example1:
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
		map.clear();
		System.out.println(map.size()); //0

4. Set<Map.Entry<K,V>> entrySet()

Example1:

	    Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        Set<Map.Entry<Integer, String>> entrySet = map.entrySet();
        System.out.println(entrySet);

5. void forEach(BiConsumer<K key, V value> biconsumer)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        
        map.forEach((var key, var val) -> {}); //DOES COMPILE 
        map.forEach((var key, var val) -> {
            System.out.println(key + " " + val);
        }); //DOES COMPILE 
        
        class Printer{
             void print(Object o1, Object o2){
                System.out.println(o1 + " " + o2);
            }
        }
        Printer p = new Printer();
        map.forEach(p::print); //DOES COMPILE 

6. V get(Object key)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        String v1 = map.get(1); // "a"
        CharSequence v2 = map.get(2); //DOES COMPILE   
        class Student{};       
        Student x = map.get(1); //DOES NOT COMPILE       
        StringBuilder x1 = map.get(1); //DOES NOT COMPILE       
        Object x2 = map.get(new Student()); //DOES COMPILE
		System.out.println(map.get(new Student())); // null


7. V getOrDefault(Object key, V defaultValue)

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        class Student{};
        System.out.println(map.getOrDefault(1, "c")); // "a"
        System.out.println(map.getOrDefault(1, new Student())); // DOES NOT COMPILE
        System.out.println(map.getOrDefault(5, "c")); // "c"
        System.out.println(map.getOrDefault(new Student(), "f")); // "f"
		System.out.println(map.getOrDefault(3, "d")); //null

8. boolean isEmpty()

Example1:

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        System.out.println(map.isEmpty()); //false
        map.clear();
        System.out.println(map.isEmpty()); //true

9. Set<K> keySet()

Example1:

		Map<Integer, String> map = new HashMap<>();
        map.put(1, "a"); map.put(2, "b");
        Set<Integer> s = map.keySet(); //DOES COMPILE
        Set<Object> s1 = map.keySet(); //DOES NOT COMPILE

10. V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)

Example1:
        //There is no key mapping
        HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", 150);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Shirt", 100, (oldValue, newValue) -> {
            System.out.println("never gets executed");
            return oldValue + newValue;
        }); //Integer::sum
        System.out.println("Price of Shirt: " + returnedValue);//100
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=150, Shirt=100, Bag=300, Shoes=200} //newValue provided will be taken as a value for a key

        
        //There is existing key mapping to non-null value -> recomputing Function has been applied (in it we are using new value)
       HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", 150);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Pant", 75, (oldValue, newValue) ->  oldValue + newValue); //Integer::sum
        System.out.println("Price of Pant: " + returnedValue); //225
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=225, Bag=300, Shoes=200} //recomputing Function takes precedence over newValue


        //There is existing key mapping to null value -> so newValue provided will be mapped to existing key; recomputing Function not called
        HashMap<String, Integer> prices = new HashMap<>();
        // insert entries to the HashMap
        prices.put("Shoes", 200);
        prices.put("Bag", 300);
        prices.put("Pant", null);
        System.out.println("HashMap: " + prices); //{Pant=150, Bag=300, Shoes=200}
        int returnedValue = prices.merge("Pant", 75, (oldValue, newValue) ->  oldValue + newValue); //Integer::sum
        System.out.println("Price of Pant: " + returnedValue); //75
        // print updated HashMap
        System.out.println("Updated HashMap: " + prices); //{Pant=225, Bag=300, Shoes=200} //recomputing Function takes precedence over newValue