*** For all these points, try to write custom notes and examples (with different colors) in your notebook ***

- Different types of integers (hex, octal, binary)
- Objects eligibility for GC
- Strings all (format() all methods
- Be able to differentiate between String and StringBuilder methods; edge cases; return types; different use-case examples
- String text block (methods on it indent, transalteEscaps etc, text normalization)
- Difference between list.toArray(), list.toArray(arr) and Arrays.toList(arr); and List.copyOf(collection) //uporedi metode kako rade sa aspekta referenci koje sadrze
- Arrays.compare(arr1, arr2)
- Arrays.mismatch(arr1, arr2)
- Math API methods
- Date and Time API
- Instantiating inner and static classes
- sealed classes assignements and rules (practice in .java files using Notepad)
- records (just repeat from Notes) More practice without IDE
- java and jar commands; with arguments
- Memorize built-in functiona interfaces (their SAMs), convinence methods as well as functional interfaces for prmitives (...getAsMethods() )
- Enum (simple/complex) structure
- Interface edge cases
- Pattern matching with instanceOf
- Generics - Java Docs






** Write daily API methods from:
	
	- Built-in Functional Interfaces
	- Convenience methods for Built-in Functional Interfaces
	- Functional Interfaces for Primitives
	- Primitive-Specific Functional Interfaces
	- Collections API
	- Queue and Deque methods (with Stack methods)
	- Map methods
	- Factory methods for List, Set and Map (Arrays.asList(arr), of(varargs), copyOf)
	- Static methods of Optional (Optional.of(T value), Optional.ofNullable(T value); exception/ no Exception)
	- Generics all
	- Optional instance methods (get(), isPresent(), ifPresent(Consumer c), orElseThrow(), orElseThrow(Supplier<? super Throwable> s), orElse(T value), orElseGet(Supplier s)) 
	- Stream creation (static/non-static) methods:  (empty(), of(varargs), collectionInstance.stream(), currentStream.generate(Supplier<T> s), currentStream.iterate(T seed, UnaryOperator<T> uo), currentStream.iterate(T seed, Predicate<? super T> initCondition, UnaryOperator<T> next)
	- Terminal operations on stream 
	- Intermediate operations on a Stream
	- Functiional Interfaces and theier SAMs for conversion between Streams and PrimitiveStreams !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!